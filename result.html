<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PORTATO ì»¤ìŠ¤í…€ í‹°ì¼“</title>
  <link rel="preconnect" href="https://bks0c7yrb0.execute-api.ap-northeast-2.amazonaws.com">
  <link rel="stylesheet" href="https://bks0c7yrb0.execute-api.ap-northeast-2.amazonaws.com/v1/api/css/drop_fontstream_css/?sid=gAAAAABkPXHo4qvpc1sn4CfuJL52Upc7AT8TVi8zpqX6aZtd3bQar6UDsPKea-00OVjtEVNfrYxuRy0KwyP7evvOGmFn-UJE3J2fgwZrrKxTO78AFSLAqGsk2yWcjZ17eIWeK8W_hEM0WwmzRDJ8PY0OKk9vf2d1gDahwuKJRCRKWS-LyUCxQDP7meUclfmM9WUoaP-N0gjIL5lyx-sFjuMGMGstTkeslXuA25WmkTdqzwQN4zkCffosmIAvef50EDHxTj2cl6OL" charset="utf-8" referrerpolicy="origin">
  <link rel="stylesheet" href="styles.css" />
  <style>
    
    /* ìµœì†Œí•œì˜ ë¡œì»¬ ìŠ¤íƒ€ì¼ (í”„ë¡œì íŠ¸ ì „ë°˜ styles.cssê°€ ìš°ì„ ) */
    :root { 
      --ink:#ebfeb3; 
      --bg:#3C6C71;
      --font-main: 'Sandoll SuPil', sans-serif;
      --font-sub: 'Sandoll Gwanghwamun', serif;
    }
    html,body{height:100%;margin:0;padding:0;font-family:var(--font-main);background:var(--bg);color:var(--ink);}
    .bg{position:fixed; inset:0; background:url("result/background_drag.png") center/cover no-repeat fixed; z-index:0; pointer-events:none;}
    /* bgStack compatibility (radialê³¼ ë™ì¼ êµ¬ì¡° ìœ ì§€) */
    #bgStack{position:fixed; inset:0; z-index:0; pointer-events:none;}
    #bgStack #bgLayer{position:absolute; inset:0; background:url("result/background_drag.png") center/cover no-repeat fixed;}
    #bgStack #screenOverlay{position:absolute; inset:0; background: rgba(0,0,0,0.25); mix-blend-mode:multiply; }

    .ui-root{position:relative; z-index:10; min-height:100vh; display:flex; flex-direction:column; align-items:center; padding:0; box-sizing:border-box;}
    header.site-header{position:absolute; top:0; left:0; z-index:20;}
    .logo-container{position:fixed; top:3.5vh; left:3.5vw; width:clamp(4vw,7vw,9vw); height:auto; z-index:1400; pointer-events:none; user-select:none;}
    .logo-base{display:block;width:100%;height:auto;pointer-events:none;user-select:none;position:relative;mix-blend-mode:multiply;}
    main.app{flex:1; width:100%; height:100vh; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:1vw; padding:4vh 0 0 0; box-sizing:border-box; z-index:12;}

    .title-box{background:rgba(60,108,113,0.3); border-radius:1.5vw; padding:1.5vw 2.5vw; margin-bottom:0; max-width:fit-content; text-align:center;}
    h2.result-title{margin:0; font-size:clamp(2.5vw,4vmin,3.5vw); color:var(--ink); text-align:center; font-weight:700;}
    p.result-sub{margin:0; color:rgba(235,254,179,0.9); text-align:center; line-height:1.6; font-size:clamp(1.2vw,2vmin,1.8vw);}
    
    /* ì• ë‹ˆë©”ì´ì…˜ ì ë“¤ */
    .loading-dots span {
      display: inline-block;
      animation: dotPulse 1.5s infinite;
      opacity: 0.3;
    }
    .loading-dots span:nth-child(1) {
      animation-delay: 0s;
    }
    .loading-dots span:nth-child(2) {
      animation-delay: 0.5s;
    }
    .loading-dots span:nth-child(3) {
      animation-delay: 1s;
    }
    @keyframes dotPulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.3); }
    }
    

    .ticket-wrap{position:relative; display:flex; align-items:center; justify-content:center; width:80vw; height:35vw; overflow:hidden;}
    
    /* í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œë¥¼ ì»¨í…Œì´ë„ˆë¡œ ì„¤ì • - overflow ì œì–´ */
    .ticket-background{
      position:absolute; 
      inset:0; 
      width:100%; 
      height:100%; 
      object-fit:contain; 
      z-index:1; 
      pointer-events:none;
      /* ì»¨í…Œì´ë„ˆ ì—­í• ì„ ìœ„í•œ ì¶”ê°€ ì„¤ì • */
      border-radius: inherit;
    }
    
    /* ============================================================
       ğŸ¨ í‹°ì¼“ ìš”ì†Œ ë°°ì¹˜ ì„¤ì • - ì—¬ê¸°ì„œ ì‰½ê²Œ ìˆ˜ì • ê°€ëŠ¥!
       í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ì•ˆì—ë§Œ ë°°ì¹˜ë˜ë„ë¡ ê°’ë“¤ì„ ì¡°ì •í•˜ì„¸ìš”.
       ============================================================ */
    
    /* ì¥ì†Œ ì´ë¯¸ì§€ (forest_img, lawn_img, valley_img, sea_img) */
    .forest-image{
      position:absolute; 
      left:15%; 
      bottom:5%; 
      width:45%; 
      height:auto; 
      object-fit:cover; 
      z-index:2; 
      pointer-events:none;
      /* í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ê²½ê³„ ë³´ì¥: left(5%) + width(45%) + ì—¬ë°±(5%) = 55% < 100% âœ… */
      /* í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ê²½ê³„ ë³´ì¥: bottom(5%) + height(60%) + ì—¬ë°±(5%) = 70% < 100% âœ… */
      max-width: calc(100% - 10%); /* ì¢Œìš° ê° 5% ì—¬ë°± ë³´ì¥ */
      max-height: calc(100% - 10%); /* ìƒí•˜ ê° 5% ì—¬ë°± ë³´ì¥ */
    }
    
    /* ì™¼ìª½ ì›í˜• ì¥ì‹ */
    .left-circle{
      position:absolute; 
      left:15%; 
      top:55%; 
      transform:translateY(-50%); 
      width:33%; 
      height:auto; 
      object-fit:contain; 
      z-index:3; 
      pointer-events:none;
      /* í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ê²½ê³„ ë³´ì¥: left(5%) + width(18%) + ì—¬ë°±(5%) = 28% < 100% âœ… */
      max-width: calc(100% - 10%); /* ì¢Œìš° ê° 5% ì—¬ë°± ë³´ì¥ */
      transform-origin: center center; /* íšŒì „ ì¤‘ì‹¬ì„ ì¤‘ì•™ìœ¼ë¡œ */
      animation: rotateRight 8s linear infinite; /* ì²œì²œíˆ ì˜¤ë¥¸ìª½ ë°©í–¥ìœ¼ë¡œ ë¬´í•œ íšŒì „ */
    }
    
    @keyframes rotateRight {
      from {
        transform: translateY(-50%) rotate(0deg);
      }
      to {
        transform: translateY(-50%) rotate(360deg);
      }
    }
    
    /* ì™¼ìª½ ìŠ¤ì™€ì¼ ì¥ì‹ */
    .left-swirl{
      position:absolute; 
      left:14%; 
      top:65%; 
      transform:translateY(-50%); 
      width:22%; 
      height:auto; 
      object-fit:contain; 
      z-index:4; 
      pointer-events:none;
      /* í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ê²½ê³„ ë³´ì¥: left(5%) + width(18%) + ì—¬ë°±(5%) = 28% < 100% âœ… */
      max-width: calc(100% - 10%); /* ì¢Œìš° ê° 5% ì—¬ë°± ë³´ì¥ */
    }
    
    /* ì˜¤ë¥¸ìª½ ì›í˜• ì¥ì‹ */
    .right-circle{
      position:absolute; 
      right:15%; 
      top:55%; 
      transform:translateY(-50%); 
      width:33%; 
      height:auto; 
      object-fit:contain; 
      z-index:5; 
      pointer-events:none;
      /* í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ê²½ê³„ ë³´ì¥: right(5%) + width(18%) + ì—¬ë°±(5%) = 28% < 100% âœ… */
      max-width: calc(100% - 10%); /* ì¢Œìš° ê° 5% ì—¬ë°± ë³´ì¥ */
    }
    
    /* ì˜¤ë¥¸ìª½ ì›í˜• ì•„ë˜ ì€ì€í•œ ë¹›ë‚˜ëŠ” ì› (ê°•ì¡° íš¨ê³¼) */
    .right-circle-glow{
      position:absolute; 
      /* right:15%; top:55%; transform:translateY(-50%); - JavaScriptì—ì„œ ë™ì ìœ¼ë¡œ ì„¤ì • */
      width:240px; /* ì´ˆê¸°ê°’ - JavaScriptì—ì„œ ë™ì ìœ¼ë¡œ ì¡°ì • */
      height:240px; /* ì´ˆê¸°ê°’ - JavaScriptì—ì„œ ë™ì ìœ¼ë¡œ ì¡°ì • */
      background: radial-gradient(circle, rgba(235, 254, 179, 0.7) 0%, rgba(235, 254, 179, 0.4) 30%, rgba(235, 254, 179, 0.15) 60%, transparent 100%);
      border-radius:50%; 
      z-index:4; /* í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ(1), forest-image(2), left-circle(3), left-swirl(4)ë³´ë‹¤ ë†’ê³ , right_circle(5)ë³´ë‹¤ ì•„ë˜ */
      pointer-events:none;
      filter: blur(6px); /* í…Œë‘ë¦¬ ë¸”ëŸ¬ íš¨ê³¼ (8px â†’ 6pxë¡œ ì¤„ì„) */
      opacity: 1 !important; /* ì™„ì „íˆ í‘œì‹œ - ê°•ì œ */
      visibility: visible !important; /* ê°•ì œë¡œ í‘œì‹œ */
      display: block !important; /* ê°•ì œë¡œ ë¸”ë¡ í‘œì‹œ */
      animation: glowPulse 2.5s ease-in-out infinite; /* ì›…ì›…ëŒ€ëŠ” ëŠë‚Œì˜ ë°˜ë³µ ì• ë‹ˆë©”ì´ì…˜ (3s â†’ 2.5së¡œ ë” ë¹ ë¥´ê²Œ) */
    }
    
    @keyframes glowPulse {
      0%, 100% {
        transform: scale(0.95); /* ì‘ì•„ì§€ëŠ” í¬ê¸°ë¥¼ ë” ì‘ê²Œ (1 â†’ 0.95) */
      }
      50% {
        transform: scale(1.15); /* ë” í¬ê²Œ ë³€í™” */
      }
    }
    
    /* íˆ´íŒ í‘œì‹œ ì¤‘ ê¸€ë¡œìš° ê°•ì¡° ì• ë‹ˆë©”ì´ì…˜ */
    .right-circle-glow.tooltip-active {
      background: radial-gradient(circle, rgba(235, 254, 179, 0.95) 0%, rgba(235, 254, 179, 0.75) 25%, rgba(235, 254, 179, 0.5) 50%, rgba(235, 254, 179, 0.25) 75%, transparent 100%);
      filter: blur(3px); /* ë¸”ëŸ¬ë¥¼ ì¤„ì—¬ì„œ ë” ì„ ëª…í•˜ê²Œ */
      animation: glowPulseSubtle 1.2s ease-in-out infinite;
    }
    
    @keyframes glowPulseSubtle {
      0%, 100% {
        transform: scale(1.0);
        opacity: 1;
      }
      50% {
        transform: scale(1.08); /* í¬ê²Œ í™•ëŒ€í•˜ì§€ ì•Šê³  ì‚´ì§ë§Œ */
        opacity: 1;
      }
    }
    
    /* ============================================================
       ë°°ì¹˜ ìˆ˜ì • ê°€ì´ë“œ:
       - ì¥ì†Œ ì´ë¯¸ì§€: left, bottom, width, height ì¡°ì •
       - ì›í˜•/ìŠ¤ì™€ì¼: left/right, top, width ì¡°ì •
       - ëª¨ë“  ê°’ì€ % ë‹¨ìœ„ë¡œ í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ê¸°ì¤€
       - ìµœëŒ€ê°’ ê³„ì‚°ì‹: calc(100% - [ì¢Œìš°ì—¬ë°±í•©])
       ============================================================ */
    
    .ticket-content{position:absolute; inset:0; display:block; padding:0; pointer-events:none; z-index:15; overflow:hidden;}
    .ticket-content img{object-fit:contain; pointer-events:none; display:block;}
    .ticket-content .draggable-img{width: auto; height: auto;}
    
    /* ë“œë˜ê·¸ ì•ˆë‚´ íˆ´íŒ */
    .drag-tooltip {
      position: fixed;
      background: rgba(60, 108, 113, 0.95);
      color: rgba(235, 254, 179, 0.95);
      padding: clamp(0.8vw, 1.2vmin, 1.2vw) clamp(1.2vw, 1.8vmin, 1.8vw);
      border-radius: clamp(0.6vw, 1vmin, 1vw);
      border: 1px solid rgba(235, 254, 179, 0.4);
      font-size: clamp(0.9vw, 1.4vmin, 1.3vw);
      font-family: var(--font-main);
      line-height: 1.4;
      white-space: nowrap;
      pointer-events: none;
      z-index: 3000;
      opacity: 0;
      transform: translate(-50%, -100%) translateY(-10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }
    
    .drag-tooltip.show {
      opacity: 1;
      transform: translate(-50%, -100%) translateY(0);
    }
    
    .drag-tooltip.hide {
      opacity: 0;
      transform: translate(-50%, -100%) translateY(-10px);
    }

    .ticket-footer{display:flex; gap:2vw; align-items:center; justify-content:flex-start; margin-top:1.5vh; margin-bottom:1vh; z-index:12; position:relative; padding-left:0; width:80vw; margin-left:auto; margin-right:auto;}
    .ticket-footer img.btn-img{height:3.5vw !important; max-height:3.5vw !important; min-height:3.5vw !important; cursor:pointer; display:block; width:auto; object-fit:contain; vertical-align:middle;}
    .ticket-footer img#btnReset{height:2.8vw !important; max-height:2.8vw !important; min-height:2.8vw !important; vertical-align:middle; margin-left:10vw;}
    .ticket-footer .footer-buttons-right{display:flex; gap:2vw; align-items:center; margin-left:auto; margin-right:auto;}

    .controls { display:flex; gap:1.2vw; align-items:center; justify-content:center; margin-top:1.2vw; z-index:12;}
    .controls a, .controls button { background:transparent; border:0; color:var(--ink); cursor:pointer; font-size:clamp(0.8vw,1.4vmin,1.2vw); padding:0.45vw 0.8vw; border-radius:0.8vw; }

    footer.site-footer{position:fixed; bottom:2vh; left:50%; transform:translateX(-50%); font-size:1vw; opacity:.9; z-index:21; margin:0; color:var(--ink); text-align:center; font-family:var(--font-sub);}

    /* small screens */
    @media (max-width:600px){
      .ticket-wrap{width:90vw; height:40vw; overflow:hidden;}
      .ticket-background{width:100%; height:100%;}
      /* ëª¨ë°”ì¼ì—ì„œë„ ë°ìŠ¤í¬í†±ê³¼ ë™ì¼í•œ ë°°ì¹˜ (ë¹„ìœ¨ ìœ ì§€) */
      .forest-image{width:45%; height:60%; left:5%; bottom:5%; max-width:calc(100% - 10%); max-height:calc(100% - 10%);}
      .left-circle, .left-swirl{width:18%; height:auto; left:5%; max-width:calc(100% - 10%);}
      .right-circle{width:18%; height:auto; right:5%; max-width:calc(100% - 10%);}
      /* ëª¨ë°”ì¼ì—ì„œë„ í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ì•ˆì—ë§Œ ë°°ì¹˜ */
      /* .right-circle-glowëŠ” JavaScriptì—ì„œ ë™ì ìœ¼ë¡œ í¬ê¸° ì„¤ì • */
    }

    /* ë¡œë”© í™”ë©´ ìŠ¤íƒ€ì¼ */
    #loadingOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 3vw;
      opacity: 1;
      transition: opacity 0.5s ease;
    }

    #loadingOverlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-pose-container {
      width: 10vw;
      height: 10vw;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .loading-pose {
      position: absolute;
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0;
      transition: opacity 0.25s ease;
    }

    .loading-pose.active {
      opacity: 1;
    }

    .loading-progress-container {
      width: 50vw;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1vw;
    }

    .loading-text {
      font-size: clamp(1.2vw, 2vmin, 1.8vw);
      color: #EBFEB3;
      font-family: var(--font-main);
      text-align: center;
      margin-bottom: 1vw;
    }

    .loading-bar-bg {
      width: 100%;
      height: 8px;
      background: rgba(235, 254, 179, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }

    .loading-bar-fill {
      height: 100%;
      background: #EBFEB3;
      border-radius: 10px;
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(235, 254, 179, 0.5);
    }

    .loading-percentage {
      font-size: clamp(1vw, 1.8vmin, 1.5vw);
      color: rgba(235, 254, 179, 0.8);
      font-family: var(--font-sub);
      margin-top: 0.5vw;
    }
  </style>
  <!-- QR ì½”ë“œ ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
  <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>
  <!-- html2canvas ë¼ì´ë¸ŒëŸ¬ë¦¬ (DOM ìš”ì†Œë¥¼ ì´ë¯¸ì§€ë¡œ ìº¡ì²˜) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <!-- ë¡œë”© í™”ë©´ -->
  <div id="loadingOverlay">
    <div class="loading-pose-container">
      <img class="loading-pose active" src="loading/pose1.svg" alt="ë¡œë”© ì¤‘" data-pose="1" onerror="console.error('pose1.svg ë¡œë“œ ì‹¤íŒ¨')" />
      <img class="loading-pose" src="loading/pose2.svg" alt="ë¡œë”© ì¤‘" data-pose="2" onerror="console.error('pose2.svg ë¡œë“œ ì‹¤íŒ¨')" />
      <img class="loading-pose" src="loading/pose3.svg" alt="ë¡œë”© ì¤‘" data-pose="3" onerror="console.error('pose3.svg ë¡œë“œ ì‹¤íŒ¨')" />
      <img class="loading-pose" src="loading/pose4.svg" alt="ë¡œë”© ì¤‘" data-pose="4" onerror="console.error('pose4.svg ë¡œë“œ ì‹¤íŒ¨')" />
    </div>
    
    <div class="loading-progress-container">
      <div class="loading-text">í‹°ì¼“ì„ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...</div>
      <div class="loading-bar-bg">
        <div class="loading-bar-fill" id="loadingBarFill"></div>
      </div>
      <div class="loading-percentage" id="loadingPercentage">0%</div>
    </div>
  </div>

  <!-- ê¸°ì¡´ radial í˜ì´ì§€ì™€ ë™ì¼í•œ ë°°ê²½/overlay êµ¬ì¡° ìœ ì§€ -->
  <div id="bgStack" aria-hidden="true">
    <div id="bgLayer"></div>
    <div id="screenOverlay"></div>
  </div>

  <div class="ui-root">
    <header class="site-header" role="banner">
      <div class="logo-container" aria-hidden="true">
        <img class="logo-base" src="asset/symbollogo.png" alt="PORTATO ë¡œê³ " />
      </div>
    </header>

    <main class="app" role="main">
      <div class="title-box">
      <h2 class="result-title">í¬ë¥´íƒ€í†  ì»¤ìŠ¤í…€ í‹°ì¼“ ë°œê¸‰ì¤‘<span class="loading-dots"><span>.</span><span>.</span><span>.</span></span></h2>
      </div>
      <p class="result-sub">
        ë‹¹ì‹ ì´ ìƒìƒí•œ ê³µì—°ì˜ ìˆœê°„ì´ í‹°ì¼“ì— ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.<br>
        ê·¸ë˜í”½ì„ ì›€ì§ì—¬ ë‹¹ì‹ ë§Œì˜ í‹°ì¼“ì„ ì™„ì„±í•˜ê³ ,<br>
        ë°œê¸‰ë°›ê¸° ë²„íŠ¼ì„ ëˆŒëŸ¬ ë‹¹ì‹ ì˜ ê³µì—°ì„ í¬ë¥´íƒ€í† ì˜ ê¸°ë¡ ì†ì— ë‚¨ê¸°ì„¸ìš”.
      </p>

      <!-- í‹°ì¼“ ì˜ì—­ -->
      <div class="ticket-wrap" id="ticketWrap" aria-hidden="false">
        <!-- ìƒˆë¡œìš´ í‹°ì¼“ ë””ìì¸ - ë ˆì´ì–´ ìˆœì„œëŒ€ë¡œ ë°°ì¹˜ -->
        <img id="ticketBack" class="ticket-background" src="result/ticket/ticket_back.svg" alt="í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ" />
        <img id="forestImg" class="forest-image" src="result/ticket/forest_img.png" alt="ìˆ²ì† ì´ë¯¸ì§€" />
        <img id="leftCircle" class="left-circle" src="result/ticket/left_circle.svg" alt="ì™¼ìª½ ì›í˜•" />
        <img id="leftSwirl" class="left-swirl" src="result/ticket/left_swirl.svg" alt="ì™¼ìª½ ìŠ¤ì™€ì¼" />
        <div class="right-circle-glow"></div>
        <img id="rightCircle" class="right-circle" src="result/ticket/right_circle.svg" alt="ì˜¤ë¥¸ìª½ ì›í˜•" />
        
        <div class="ticket-content" id="ticketContent" aria-hidden="false">
          <!-- ì„ íƒ í•­ëª© ë¯¸ë¦¬ë³´ê¸°(ì‘ì€ ì•„ì´ì½˜ë“¤) ì‚½ì… - JavaScriptë¡œ ë™ì  ìƒì„± -->
          
          <!-- ì‚¬ìš©ì ì„ íƒì— ë”°ë¥¸ ë™ì  ì´ë¯¸ì§€ í‘œì‹œ ì˜ì—­ -->
          <!-- JavaScriptë¡œ ë™ì  ìƒì„±ë¨ -->
          
          <!-- ì‚¬ìš©ì ì„ íƒì— ë”°ë¥¸ ë™ì  ì´ë¯¸ì§€ í‘œì‹œ ì˜ì—­ -->
          <!-- JavaScriptë¡œ ë™ì  ìƒì„±ë¨ -->
        </div>
      </div>

      <!-- ë²„íŠ¼ë“¤ (ì´ë¯¸ì§€ ë²„íŠ¼) -->
      <div class="ticket-footer">
        <img id="btnReset" class="btn-img" src="result/reset-btn.svg" alt="ìœ„ì¹˜ ì´ˆê¸°í™”" title="ìœ„ì¹˜ ì´ˆê¸°í™”" />
        <div class="footer-buttons-right">
        <img id="btnReselect" class="btn-img" src="asset/reselect-btn.svg" alt="ë‹¤ì‹œ ì„ íƒ" title="ë‹¤ì‹œ ì„ íƒ" />
        <img id="btnUseTicket" class="btn-img" src="asset/getticket-btn.svg" alt="í‹°ì¼“ ì‚¬ìš©í•˜ê¸°" title="í‹°ì¼“ ì‚¬ìš©í•˜ê¸°" />
        </div>
      </div>

      <!-- QR ë° ìƒíƒœ -->
      <div class="controls" id="qrArea" aria-hidden="true" style="display:none;">
        <div id="qrWrap" style="display:flex;flex-direction:column;align-items:center;gap:0.8vw;">
          <img id="qrImg" alt="í‹°ì¼“ QR ì½”ë“œ" width="160" height="160" style="background:#fff;border-radius:0.8vw;"/>
          <div style="font-size:clamp(0.7vw,1.2vmin,1vw);color:var(--ink);opacity:.95">QRì„ ìŠ¤ìº”í•˜ë©´ í‹°ì¼“ ì´ë¯¸ì§€ë¥¼ ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
        </div>
      </div>

    </main>

    <footer class="site-footer">
      <small>Â© 2025 PORTATO</small>
    </footer>
  </div>

<script>
/*
  result.html logic
  - reads localStorage.portatoSelections (object)
  - displays small preview images on ticket
  - composes a PNG of the ticket by loading ticket left/right/line + preview images into canvas
  - provides: download button (PNG), "use ticket" which saves to archive (localStorage), and shows QR image (Google Chart QR API)
*/

// ========================================
// ë¡œë”© í™”ë©´ ê´€ë¦¬
// ========================================
let loadingProgress = 0;
let loadingInterval = null;
let poseInterval = null;
let currentPoseIndex = 0;

// ëœë¤ pose ì „í™˜ ì‹œì‘
function startPoseAnimation() {
  const poses = document.querySelectorAll('.loading-pose');
  console.log('ğŸ­ í¬ì¦ˆ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘, í¬ì¦ˆ ê°œìˆ˜:', poses.length);
  
  if (poses.length === 0) {
    console.error('âŒ í¬ì¦ˆ ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
    return;
  }
  
  poseInterval = setInterval(() => {
    // í˜„ì¬ pose ë¹„í™œì„±í™”
    poses[currentPoseIndex].classList.remove('active');
    
    // ëœë¤í•˜ê²Œ ë‹¤ìŒ pose ì„ íƒ (í˜„ì¬ pose ì œì™¸)
    let nextIndex;
    do {
      nextIndex = Math.floor(Math.random() * poses.length);
    } while (nextIndex === currentPoseIndex);
    
    currentPoseIndex = nextIndex;
    poses[currentPoseIndex].classList.add('active');
    console.log(`ğŸ”„ í¬ì¦ˆ ì „í™˜: ${currentPoseIndex + 1}`);
  }, 400); // 0.4ì´ˆë§ˆë‹¤ ì „í™˜
}

// ì§„í–‰ ë°” ì—…ë°ì´íŠ¸
function updateLoadingProgress(progress) {
  loadingProgress = Math.min(100, progress);
  const barFill = document.getElementById('loadingBarFill');
  const percentage = document.getElementById('loadingPercentage');
  
  if (barFill) barFill.style.width = loadingProgress + '%';
  if (percentage) percentage.textContent = Math.round(loadingProgress) + '%';
}

// ë¡œë”© ì‹œì‘
function showLoading() {
  const overlay = document.getElementById('loadingOverlay');
  console.log('ğŸ¬ showLoading í˜¸ì¶œë¨, overlay:', overlay);
  if (overlay) {
    overlay.classList.remove('hidden');
    loadingProgress = 0;
    updateLoadingProgress(0);
    startPoseAnimation();
    console.log('âœ… ë¡œë”© í™”ë©´ í‘œì‹œ ì™„ë£Œ');
  } else {
    console.error('âŒ loadingOverlay ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
  }
}

// ë¡œë”© ì¢…ë£Œ
function hideLoading() {
  const overlay = document.getElementById('loadingOverlay');
  console.log('ğŸ hideLoading í˜¸ì¶œë¨, overlay:', overlay);
  
  // ì§„í–‰ ë°”ë¥¼ 100%ë¡œ
  updateLoadingProgress(100);
  console.log('âœ… ì§„í–‰ë¥  100% ì„¤ì • ì™„ë£Œ');
  
  // ì• ë‹ˆë©”ì´ì…˜ ì •ë¦¬
  if (poseInterval) {
    clearInterval(poseInterval);
    poseInterval = null;
    console.log('âœ… í¬ì¦ˆ ì• ë‹ˆë©”ì´ì…˜ ì •ë¦¬ ì™„ë£Œ');
  }
  
  // 0.5ì´ˆ í›„ ë¡œë”© í™”ë©´ ìˆ¨ê¹€
  setTimeout(() => {
    if (overlay) {
      overlay.classList.add('hidden');
      console.log('âœ… ë¡œë”© í™”ë©´ ìˆ¨ê¹€ ì™„ë£Œ');
    }
  }, 500);
}

// ì ì§„ì  ë¡œë”© ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œ ì‘ì—… ì§„í–‰ë„ ë°˜ì˜)
function simulateLoadingProgress(targetProgress, duration) {
  const startProgress = loadingProgress;
  const progressDiff = targetProgress - startProgress;
  const startTime = Date.now();
  
  console.log(`ğŸ“ˆ ì§„í–‰ë¥  ì‹œë®¬ë ˆì´ì…˜: ${startProgress}% â†’ ${targetProgress}% (${duration}ms)`);
  
  if (loadingInterval) clearInterval(loadingInterval);
  
  loadingInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    
    const currentProgress = startProgress + (progressDiff * progress);
    updateLoadingProgress(currentProgress);
    
    if (progress >= 1) {
      clearInterval(loadingInterval);
      loadingInterval = null;
      console.log(`âœ… ì§„í–‰ë¥  ë„ë‹¬: ${targetProgress}%`);
    }
  }, 50);
}

// ========================================
// ê¸°ì¡´ ì½”ë“œ ê³„ì†
// ========================================

/* ê¸°ë³¸ ì´ë¯¸ì§€ ë§¤í•‘: (í”„ë¡œì íŠ¸ì— ë§ê²Œ ê²½ë¡œ ì¡°ì • ê°€ëŠ¥)
   ìš°ì„ ìˆœìœ„:
    1) selections.images (ì´ë¯¸ íŒŒì¼ URL ë°°ì—´ì´ ì €ì¥ë˜ì–´ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©)
    2) ê¸°ë³¸ ë§¤í•‘ IMG_MAP[group][value] -> asset/result-{group}-{value}.png (fallback)
*/
const IMG_MAP = {
  place: {
    field:  "result/place_field.png",
    forest: "result/place_forest.png",
    lake:   "result/place_lake.png",
    sea:    "result/place_sea.png"
  },
  mood: {
    classical:    "result/mood_classical.png",
    romantic:     "result/mood_romantic.png",
    impressionist:"result/mood_impressionist.png",
    neoclassical: "result/mood_neoclassical.png"
  },
  flow: {
    lie:     "result/flow_lie.png",
    sit:     "result/flow_sit.png",
    walk:    "result/flow_walk.png",
    scatter: "result/flow_scatter.png"
  },
  extras: {
    talk:       "result/extras_talk.png",
    tea:        "result/extras_tea.png",
    instrument: "result/extras_instrument.png",
    campfire:   "result/extras_campfire.png"
  }
};

const ticketBackEl = document.getElementById('ticketBack');
const forestImgEl = document.getElementById('forestImg');
const leftCircleEl = document.getElementById('leftCircle');
const leftSwirlEl = document.getElementById('leftSwirl');
const rightCircleEl = document.getElementById('rightCircle');
const rightCircleGlowEl = document.querySelector('.right-circle-glow');
const ticketContent  = document.getElementById('ticketContent');

// right_circle í¬ê¸°ì— ë§ì¶° glow ì› í¬ê¸° ì¡°ì • í•¨ìˆ˜
function updateRightCircleGlowSize() {
  if (!rightCircleEl || !rightCircleGlowEl) {
    console.warn('âš ï¸ rightCircleEl ë˜ëŠ” rightCircleGlowElì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    console.log('rightCircleEl:', rightCircleEl);
    console.log('rightCircleGlowEl:', rightCircleGlowEl);
    return;
  }
  
  const rightCircleRect = rightCircleEl.getBoundingClientRect();
  if (rightCircleRect.width === 0 || rightCircleRect.height === 0) {
    console.warn('âš ï¸ rightCircle í¬ê¸°ê°€ 0ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.');
    setTimeout(() => updateRightCircleGlowSize(), 500);
    return;
  }
  
  // right_circleë³´ë‹¤ ì•½ê°„ ë” í¬ê²Œ (110% ì •ë„ - 115%ì—ì„œ 110%ë¡œ ì¤„ì„)
  const glowSize = Math.max(rightCircleRect.width, rightCircleRect.height) * 1.10;
  
  // right_circleì˜ ìœ„ì¹˜ì™€ ë™ì¼í•˜ê²Œ ì„¤ì •
  const ticketWrap = rightCircleEl.closest('.ticket-wrap');
  if (ticketWrap) {
    const ticketWrapRect = ticketWrap.getBoundingClientRect();
    const rightCircleLeft = rightCircleRect.left - ticketWrapRect.left;
    const rightCircleTop = rightCircleRect.top - ticketWrapRect.top;
    const rightCircleCenterX = rightCircleLeft + rightCircleRect.width / 2;
    const rightCircleCenterY = rightCircleTop + rightCircleRect.height / 2;
    
    // glow ì›ì„ right_circle ì¤‘ì‹¬ì— ë§ì¶° ë°°ì¹˜
    rightCircleGlowEl.style.left = 'auto';
    rightCircleGlowEl.style.right = 'auto';
    rightCircleGlowEl.style.top = 'auto';
    rightCircleGlowEl.style.left = (rightCircleCenterX - glowSize / 2) + 'px';
    rightCircleGlowEl.style.top = (rightCircleCenterY - glowSize / 2) + 'px';
    // transformì€ ì• ë‹ˆë©”ì´ì…˜ì—ì„œ ì‚¬ìš©í•˜ë¯€ë¡œ ì œê±°í•˜ì§€ ì•ŠìŒ (ì¤‘ì‹¬ ê¸°ì¤€ìœ¼ë¡œ scale ì ìš©)
    rightCircleGlowEl.style.transformOrigin = 'center center';
  }
  
  rightCircleGlowEl.style.width = glowSize + 'px';
  rightCircleGlowEl.style.height = glowSize + 'px';
  
  // ë””ë²„ê¹…: ì‹¤ì œ ì ìš©ëœ ìŠ¤íƒ€ì¼ í™•ì¸
  const computedStyle = window.getComputedStyle(rightCircleGlowEl);
  console.log('âœ¨ Glow ì› í¬ê¸° ì—…ë°ì´íŠ¸:', glowSize + 'px (right_circle: ' + rightCircleRect.width + 'x' + rightCircleRect.height + ')');
  console.log('ğŸ“ Glow ìœ„ì¹˜:', rightCircleGlowEl.style.left, rightCircleGlowEl.style.top);
  console.log('ğŸ¨ Glow computed style:', {
    width: computedStyle.width,
    height: computedStyle.height,
    opacity: computedStyle.opacity,
    visibility: computedStyle.visibility,
    display: computedStyle.display,
    zIndex: computedStyle.zIndex,
    background: computedStyle.background
  });
}
const btnReset = document.getElementById('btnReset');
const btnReselect = document.getElementById('btnReselect');
const btnUseTicket = document.getElementById('btnUseTicket');
const btnDownload = document.getElementById('btnDownload');
if (!btnDownload) {
  console.warn('btnDownload ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥ì„ ê±´ë„ˆëœë‹ˆë‹¤.');
}
const qrArea = document.getElementById('qrArea');
const qrImg = document.getElementById('qrImg');

const ARCHIVE_KEY = "portato_archive_v1";
const STORAGE_THRESHOLD = 4 * 1024 * 1024; // 4MB (ì•ˆì „í•œ ì„ê³„ê°’)
const STORAGE_TARGET = 3 * 1024 * 1024; // 3MB (ì••ì¶• í›„ ëª©í‘œ ìš©ëŸ‰)

// localStorage ìš©ëŸ‰ ì²´í¬ (ê·¼ì‚¬ì¹˜)
function getStorageSize() {
  let total = 0;
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    const value = localStorage.getItem(key);
    total += key.length + value.length;
  }
  return total;
}

// ì´ë¯¸ì§€ ì••ì¶• í•¨ìˆ˜ (íˆ¬ëª… ë°°ê²½ ìœ ì§€ - PNG í˜•ì‹ ìœ ì§€)
async function compressImage(dataURL, quality = 0.7) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // ì´ë¯¸ì§€ í¬ê¸°ë¥¼ 80%ë¡œ ì¤„ì„ (ìš©ëŸ‰ ëŒ€í­ ê°ì†Œ)
      const maxDimension = Math.max(img.width, img.height);
      const scale = maxDimension > 800 ? 800 / maxDimension : 0.8;
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      
      // íˆ¬ëª… ë°°ê²½ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ canvasë¥¼ ë¨¼ì € ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ
      // (íˆ¬ëª… ë°°ê²½ì€ ìë™ìœ¼ë¡œ ìœ ì§€ë¨)
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      // íˆ¬ëª… ë°°ê²½ì´ ìˆëŠ”ì§€ í™•ì¸ (PNG í˜•ì‹ì¸ ê²½ìš°)
      const isPNG = dataURL.includes('image/png') || dataURL.includes('data:image/png');
      
      if (isPNG) {
        // PNG í˜•ì‹ ìœ ì§€ (íˆ¬ëª… ë°°ê²½ ë³´ì¡´)
        // PNGëŠ” í’ˆì§ˆ íŒŒë¼ë¯¸í„°ë¥¼ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ í•´ìƒë„ë§Œ ë‚®ì¶¤
        const compressed = canvas.toDataURL('image/png');
        console.log(`ğŸ“¦ ì´ë¯¸ì§€ ì••ì¶• (PNG, íˆ¬ëª… ë°°ê²½ ìœ ì§€): ${(dataURL.length / 1024).toFixed(2)}KB â†’ ${(compressed.length / 1024).toFixed(2)}KB`);
        resolve(compressed);
      } else {
        // JPEG í˜•ì‹ì¸ ê²½ìš°ë§Œ í’ˆì§ˆ ì¡°ì •
        const compressed = canvas.toDataURL('image/jpeg', quality);
        console.log(`ğŸ“¦ ì´ë¯¸ì§€ ì••ì¶• (JPEG): ${(dataURL.length / 1024).toFixed(2)}KB â†’ ${(compressed.length / 1024).toFixed(2)}KB`);
        resolve(compressed);
      }
    };
    img.onerror = () => resolve(dataURL); // ì‹¤íŒ¨ ì‹œ ì›ë³¸ ë°˜í™˜
    img.src = dataURL;
  });
}

// ì•„ì¹´ì´ë¸Œ ìš©ëŸ‰ ê´€ë¦¬: ì˜¤ë˜ëœ ì´ë¯¸ì§€ë¶€í„° ì••ì¶•
async function manageArchiveStorage(newEntrySize) {
  const currentSize = getStorageSize();
  const estimatedSize = currentSize + newEntrySize;
  
  console.log(`ğŸ“Š í˜„ì¬ ì €ì¥ì†Œ ìš©ëŸ‰: ${(currentSize / 1024 / 1024).toFixed(2)}MB, ì˜ˆìƒ ìš©ëŸ‰: ${(estimatedSize / 1024 / 1024).toFixed(2)}MB`);
  
  // ì„ê³„ê°’ ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ ì´ë¯¸ì§€ë¶€í„° ì••ì¶•
  if (estimatedSize > STORAGE_THRESHOLD) {
    console.log('âš ï¸ ì €ì¥ì†Œ ìš©ëŸ‰ ì„ê³„ê°’ ì´ˆê³¼! ì˜¤ë˜ëœ ì´ë¯¸ì§€ ì••ì¶• ì‹œì‘...');
    
    let archive = JSON.parse(localStorage.getItem(ARCHIVE_KEY) || '[]');
    // ì˜¤ë˜ëœ ìˆœìœ¼ë¡œ ì •ë ¬ (timestamp ì˜¤ë¦„ì°¨ìˆœ)
    archive.sort((a, b) => a.timestamp - b.timestamp);
    
    let compressedCount = 0;
    for (let i = 0; i < archive.length; i++) {
      const item = archive[i];
      
      // rightCircleImageê°€ ìˆê³  ì••ì¶•ë˜ì§€ ì•Šì€ ê²½ìš°ë§Œ ì••ì¶•
      // compressed í”Œë˜ê·¸ê°€ ì—†ê±°ë‚˜, PNG í˜•ì‹ì¸ ê²½ìš° ì••ì¶• (íˆ¬ëª… ë°°ê²½ ìœ ì§€)
      if (item.rightCircleImage && !item.compressed) {
        const originalSize = item.rightCircleImage.length;
        const compressed = await compressImage(item.rightCircleImage, 0.7);
        item.rightCircleImage = compressed;
        item.compressed = true; // ì••ì¶• í”Œë˜ê·¸ ì¶”ê°€
        
        compressedCount++;
        console.log(`âœ… ${i + 1}ë²ˆì§¸ ì•„ì´í…œ ì••ì¶• ì™„ë£Œ`);
        
        // ì••ì¶• í›„ ìš©ëŸ‰ ì¬í™•ì¸
        const testArchive = JSON.parse(JSON.stringify(archive));
        const testSize = new Blob([JSON.stringify(testArchive)]).size;
        if (testSize < STORAGE_TARGET) {
          console.log(`âœ… ëª©í‘œ ìš©ëŸ‰ ë‹¬ì„±: ${(testSize / 1024 / 1024).toFixed(2)}MB`);
          break;
        }
      }
    }
    
    // ì••ì¶•ëœ ì•„ì¹´ì´ë¸Œ ì €ì¥
    localStorage.setItem(ARCHIVE_KEY, JSON.stringify(archive));
    console.log(`ğŸ“¦ ì´ ${compressedCount}ê°œ ì´ë¯¸ì§€ ì••ì¶• ì™„ë£Œ`);
  }
}
const SELECTION_KEY = "portatoSelections";

/* selections í˜•ì‹ ì˜ˆìƒ:
  {
    place: "forest",
    mood: "classical",
    flow: "sit",
    extras: "tea",
    instruments: ["ë°”ì´ì˜¬ë¦°","ì²¼ë¡œ"],
    // optional: images: ["asset/...", ...]  <-- ìš°ì„ ìˆœìœ„ë¡œ ì‚¬ìš©
  }
*/
const selections = JSON.parse(localStorage.getItem(SELECTION_KEY) || "{}");

// ë””ë²„ê¹…: localStorage ì „ì²´ ë‚´ìš© í™•ì¸
console.log('=== localStorage ì „ì²´ ë‚´ìš© ===');
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  const value = localStorage.getItem(key);
  console.log(`í‚¤: "${key}", ê°’:`, value);
}

console.log('=== portatoSelections íŠ¹ë³„ í™•ì¸ ===');
const rawSelections = localStorage.getItem(SELECTION_KEY);
console.log('ì›ë³¸ JSON ë¬¸ìì—´:', rawSelections);
console.log('íŒŒì‹±ëœ selections ê°ì²´:', selections);
console.log('selections íƒ€ì…:', typeof selections);
console.log('selections í‚¤ë“¤:', Object.keys(selections));

// GitHub Pages base path ìë™ ê°ì§€
function getBasePath() {
  const path = window.location.pathname;
  // GitHub Pagesì—ì„œ ì €ì¥ì†Œ ì´ë¦„ì´ URLì— í¬í•¨ëœ ê²½ìš°
  // ì˜ˆ: /repo-name/result.html â†’ /repo-name/
  // ì˜ˆ: /repo-name/ â†’ /repo-name/
  const pathParts = path.split('/').filter(p => p);
  
  // íŒŒì¼ì´ ë£¨íŠ¸ì— ìˆëŠ” ê²½ìš° (ì˜ˆ: /result.html)
  if (pathParts.length === 1 && pathParts[0].endsWith('.html')) {
    return '/';
  }
  
  // íŒŒì¼ì´ í•˜ìœ„ ë””ë ‰í† ë¦¬ì— ìˆëŠ” ê²½ìš° (ì˜ˆ: /repo-name/result.html)
  if (pathParts.length > 1) {
    const lastPart = pathParts[pathParts.length - 1];
    if (lastPart.endsWith('.html')) {
      // HTML íŒŒì¼ì´ ìˆëŠ” ê²½ìš°, ê·¸ ìƒìœ„ ë””ë ‰í† ë¦¬ê¹Œì§€ê°€ base path
      const basePath = '/' + pathParts.slice(0, -1).join('/') + '/';
      return basePath;
    }
    // HTML íŒŒì¼ì´ ì•„ë‹Œ ê²½ìš° (ì˜ˆ: /repo-name/)
    const basePath = '/' + pathParts.join('/') + '/';
    return basePath;
  }
  
  // ë£¨íŠ¸ì— ìˆëŠ” ê²½ìš°
  return '/';
}

// ìƒëŒ€ ê²½ë¡œë¥¼ ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜ (GitHub Pages í˜¸í™˜)
// ë¡œì»¬ì—ì„œëŠ” ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê³ , GitHub Pagesì—ì„œë§Œ ê²½ë¡œ ìˆ˜ì •
function resolvePath(relativePath) {
  if (!relativePath) return relativePath;
  
  // ì´ë¯¸ ì ˆëŒ€ ê²½ë¡œì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (relativePath.startsWith('http://') || relativePath.startsWith('https://') || relativePath.startsWith('data:')) {
    return relativePath;
  }
  
  // ë¡œì»¬ í™˜ê²½ (file:// ë˜ëŠ” localhost)ì—ì„œëŠ” ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (window.location.protocol === 'file:' || 
      window.location.hostname === 'localhost' || 
      window.location.hostname === '127.0.0.1') {
    return relativePath;
  }
  
  // GitHub Pagesì—ì„œë§Œ base path ì¶”ê°€
  const basePath = getBasePath();
  
  // base pathê°€ '/'ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜ (ë£¨íŠ¸ì— ë°°í¬ëœ ê²½ìš°)
  if (basePath === '/') {
    return relativePath.startsWith('/') ? relativePath : '/' + relativePath;
  }
  
  // base pathê°€ ìˆëŠ” ê²½ìš° (ì €ì¥ì†Œ ì´ë¦„ì´ URLì— í¬í•¨ëœ ê²½ìš°)
  const cleanBasePath = basePath.endsWith('/') ? basePath.slice(0, -1) : basePath;
  const cleanRelativePath = relativePath.startsWith('/') ? relativePath.slice(1) : relativePath;
  return cleanBasePath + '/' + cleanRelativePath;
}

// helper: ì•ˆì „í•œ ì´ë¯¸ì§€ ë¡œë“œ (Image ê°ì²´ -> Promise)
function loadImage(src){
  return new Promise((resolve) => {
    // file:// í”„ë¡œí† ì½œì—ì„œëŠ” CORS ì„¤ì •ì´ ì‘ë™í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, 
    // ì´ë¯¸ì§€ë¥¼ canvasì— ê·¸ë¦´ ë•Œ blobìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì‚¬ìš©
    const img = new Image();
    // crossOrigin ë¬¸ì œ ë°©ì§€ë¥¼ ìœ„í•´ crossOriginì„ ì„¤ì •í•˜ì§€ ì•ŠìŒ
    img.onload = ()=> resolve(img);
    img.onerror = ()=> {
      console.warn("ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:", src);
      resolve(null);
    };
    // GitHub Pages í˜¸í™˜ì„ ìœ„í•´ ê²½ë¡œ í•´ê²°
    img.src = resolvePath(src);
  });
}

// ì¥ì†Œë³„ ë°°ê²½ ì´ë¯¸ì§€ ë§¤í•‘ (ê²½ë¡œëŠ” loadImageì—ì„œ ìë™ í•´ê²°)
const PLACE_BACKGROUNDS = {
  'lawn': 'result/ticket/lawn_img.png',
  'forest': 'result/ticket/forest_img.png',
  'valley': 'result/ticket/valley_img.png',
  'sea': 'result/ticket/sea_img.png'
};

// í‚¤ì›Œë“œë³„ ì´ë¯¸ì§€ ë§¤í•‘ (value ê°’ì„ í‚¤ë¡œ ì‚¬ìš©) - left í´ë” ì´ë¯¸ì§€ë§Œ ì‚¬ìš©
const KEYWORD_IMAGES = {
  // ì¥ì†Œ (place) - value: ì˜ë¬¸ íŒŒì¼ëª…
  'lawn': { left: 'result/left/Lawn.svg' },
  'forest': { left: 'result/left/Forest.svg' },
  'valley': { left: 'result/left/Valley.svg' },
  'sea': { left: 'result/left/Sea.svg' },
  
  // ìŒì•… ìŠ¤íƒ€ì¼ (mood) - value: ì˜ë¬¸ íŒŒì¼ëª…
  'baroque': { left: 'result/left/Baroque.svg' },
  'romantic': { left: 'result/left/Romanticism.svg' },
  'impression': { left: 'result/left/Impressionism.svg' },
  'post': { left: 'result/left/Postmodernism.svg' },
  
  // ìì„¸ (flow) - value: ì˜ë¬¸ íŒŒì¼ëª…
  'recline': { left: 'result/left/Recline.svg' },
  'lounge': { left: 'result/left/Lounge.svg' },
  'settle': { left: 'result/left/Settle.svg' },
  'wander': { left: 'result/left/Wander.svg' },
  
  // ê²½í—˜ (extras) - value: ì˜ë¬¸ íŒŒì¼ëª…
  'dialogue': { left: 'result/left/Dialogue.svg' },
  'refresh': { left: 'result/left/Treats.svg' },
  'play': { left: 'result/left/Playground.svg' },
  'fire': { left: 'result/left/Fireworks.svg' },
  
  // ì•…ê¸° (instruments) - í•œê¸€ëª…: ì˜ë¬¸ íŒŒì¼ëª… (left í´ë”ë§Œ ì‚¬ìš©)
  'ë°”ì´ì˜¬ë¦°': { left: 'result/left/instruments/Vn.svg' },
  'ë¹„ì˜¬ë¼': { left: 'result/left/instruments/Vla.svg' },
  'ì²¼ë¡œ': { left: 'result/left/instruments/Vc.svg' },
  'íŠ¸ëŸ¼ë³¸': { left: 'result/left/instruments/Trb.svg' },
  'íŠ¸ëŸ¼í«': { left: 'result/left/instruments/Tp.svg' },
  'í˜¸ë¥¸': { left: 'result/left/instruments/Hn.svg' },
  'í”Œë£»': { left: 'result/left/instruments/Fl.svg' },
  'í´ë¼ë¦¬ë„·': { left: 'result/left/instruments/Cl.svg' },
  'ì½˜íŠ¸ë¼ë² ì´ìŠ¤': { left: 'result/left/instruments/Cb.svg' }
};

// build preview list (ticketContent)
function buildPreview(){
  console.log('========================================');
  console.log('buildPreview() í•¨ìˆ˜ ì‹œì‘!');
  console.log('========================================');
  
  // ë¡œë”© ì§„í–‰: 10% â†’ 30%
  simulateLoadingProgress(30, 500);
  
  ticketContent.innerHTML = "";
  
  // ë””ë²„ê¹…: ì „ì²´ selections êµ¬ì¡° í™•ì¸
  console.log('=== ì „ì²´ selections ê°ì²´ ===', selections);
  console.log('selectionsì˜ ëª¨ë“  í‚¤:', Object.keys(selections));
  
  // ticketContent ìš”ì†Œ í™•ì¸
  console.log('ticketContent ìš”ì†Œ:', ticketContent);
  console.log('ticketContentê°€ DOMì— ì¡´ì¬:', !!ticketContent);
  console.log('ticketContent í¬ê¸°:', ticketContent.getBoundingClientRect());
  
  // ì‚¬ìš©ì ì„ íƒëœ value ê°’ë“¤ ê°€ì ¸ì˜¤ê¸°
  const selectedValues = [];
  
  // ê° ë‹¨ê³„ë³„ë¡œ ì„ íƒëœ value ìˆ˜ì§‘ (place, mood, flow, extras)
  if (selections.place) selectedValues.push(selections.place);
  if (selections.mood) selectedValues.push(selections.mood);
  if (selections.flow) selectedValues.push(selections.flow);
  if (selections.extras) selectedValues.push(selections.extras);
  
  // ì•…ê¸° ì„ íƒë„ ì¶”ê°€ (ìµœëŒ€ 3ê°œ)
  if (selections.instruments && Array.isArray(selections.instruments)) {
    selections.instruments.slice(0, 3).forEach(instrument => {
      selectedValues.push(instrument);
    });
  }
  
  console.log('ì„ íƒëœ value ê°’ë“¤:', selectedValues);
  
  // ë§Œì•½ ì„ íƒê°’ì´ ì—†ë‹¤ë©´ í…ŒìŠ¤íŠ¸ìš© ê°’ ì¶”ê°€
  if (selectedValues.length === 0) {
    console.warn('ì„ íƒëœ ê°’ì´ ì—†ìŠµë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ìš© ê°’ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.');
    selectedValues.push('lawn', 'baroque', 'recline', 'dialogue', 'ë°”ì´ì˜¬ë¦°', 'ì²¼ë¡œ');
  }
  
  console.log('=== ì„ íƒëœ ê°’ë“¤ ìƒì„¸ ë¶„ì„ ===');
  selectedValues.forEach((value, index) => {
    const imageData = KEYWORD_IMAGES[value];
    console.log(`${index + 1}. value: "${value}"`);
    console.log(`   ì´ë¯¸ì§€ ë°ì´í„°:`, imageData);
    if (imageData) {
      console.log(`   Left ì´ë¯¸ì§€ ê²½ë¡œ: ${imageData.left}`);
      console.log(`   Right ì´ë¯¸ì§€ ê²½ë¡œ: ${imageData.right}`);
    } else {
      console.log(`   âŒ ë§¤í•‘ëœ ì´ë¯¸ì§€ ë°ì´í„° ì—†ìŒ!`);
    }
  });
  
  // ì„ íƒëœ valueì— í•´ë‹¹í•˜ëŠ” ì´ë¯¸ì§€ë“¤ ë¡œë“œ
  const imagePromises = selectedValues.map(value => {
    const imageData = KEYWORD_IMAGES[value];
    if (!imageData) {
      console.warn('valueì— í•´ë‹¹í•˜ëŠ” ì´ë¯¸ì§€ ì—†ìŒ:', value);
      return Promise.resolve(null);
    }
    
    console.log(`value "${value}"ì— ëŒ€í•œ ì´ë¯¸ì§€ ë¡œë“œ ì‹œë„:`, imageData);
    
    // left ì´ë¯¸ì§€ë§Œ ë¡œë“œ
    return loadImage(imageData.left).then(leftImg => {
      console.log(`value "${value}" ì´ë¯¸ì§€ ë¡œë“œ ê²°ê³¼:`, {
        leftLoaded: !!leftImg
      });
      if (leftImg) {
        return { value, leftImg };
      }
      return null;
    });
  });
  
  return Promise.all(imagePromises).then(imageResults => {
    console.log('ëª¨ë“  ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ:', imageResults);
    
    // ë¡œë”© ì§„í–‰: 30% â†’ 60%
    simulateLoadingProgress(60, 800);
    
    const validResults = imageResults.filter(result => result !== null);
    console.log('ìœ íš¨í•œ ì´ë¯¸ì§€ ê²°ê³¼ ê°œìˆ˜:', validResults.length);
    
    // í‹°ì¼“ ì»¨í…ì¸  ì˜ì—­ì— left ì´ë¯¸ì§€ë§Œ ì¶”ê°€
    const imageContainer = document.createElement('div');
    
    imageContainer.style.cssText = `
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 1vw;
      width: 100%;
      height: 100%;
      padding: 1vw;
      position: relative;
      z-index: 20;
    `;
    
    // ê° ì„ íƒëœ valueì˜ left ì´ë¯¸ì§€ë§Œ ì¶”ê°€
    validResults.forEach((result, index) => {
      console.log(`ì´ë¯¸ì§€ ${index + 1} ì¶”ê°€ ì¤‘:`, result.value);
      
      // Left ì´ë¯¸ì§€ë§Œ ì‚¬ìš©
      const leftImg = result.leftImg.cloneNode();
      leftImg.style.cssText = `
        width: 8% !important;
        height: 8% !important;
        object-fit: contain;
        display: block !important;
        position: relative;
        z-index: 100 !important;
        margin: 0.5% !important;
      `;
      imageContainer.appendChild(leftImg);
      console.log(`Left ì´ë¯¸ì§€ ì¶”ê°€ ì™„ë£Œ:`, leftImg);
    });
    
    // ì»¨í…Œì´ë„ˆë¥¼ í‹°ì¼“ ì»¨í…ì¸ ì— ì¶”ê°€
    ticketContent.appendChild(imageContainer);
    
    console.log('í‹°ì¼“ ì»¨í…ì¸ ì— ì´ë¯¸ì§€ ì»¨í…Œì´ë„ˆ ì¶”ê°€ ì™„ë£Œ');
    console.log('imageContainer ìì‹ ê°œìˆ˜:', imageContainer.children.length);
    console.log('ticketContent ìì‹ ê°œìˆ˜:', ticketContent.children.length);
    console.log('ìœ íš¨í•œ ê²°ê³¼ ê°œìˆ˜:', validResults.length);
    
    return validResults;
  });
}

/* Render ticket as PNG by composing images onto canvas:
   layout strategy:
    - desired ticket height = ticketHalfHeight (we follow DOM height)
    - load left/right images -> scale each to ticketHeight preserving aspect
    - canvas width = leftW + rightW
    - draw left at x=0, draw right at x=leftW
    - draw ticketLine stretched to full width (if available) on top
    - draw preview icons centered on the ticket content area (we simply draw them centered)
*/
async function composeTicketDataURL(){
  try {
    console.log('ğŸ« í‹°ì¼“ ìƒì„± ì‹œì‘...');
    
    // DOM sizes (ticket halves height controlled by CSS)
    const ticketWrapRect = document.getElementById('ticketWrap').getBoundingClientRect();
    const desiredHeight = Math.round(ticketWrapRect.height); // px
    
    console.log('ğŸ“ í‹°ì¼“ í¬ê¸°:', ticketWrapRect.width, 'x', ticketWrapRect.height);

    // load base images
    console.log('ğŸ–¼ï¸ ë² ì´ìŠ¤ ì´ë¯¸ì§€ ë¡œë“œ ì¤‘...');
    console.log('ğŸ“ ì´ë¯¸ì§€ ì†ŒìŠ¤:', {
      ticketBack: ticketBackEl?.src,
      forest: forestImgEl?.src,
      leftCircle: leftCircleEl?.src,
      leftSwirl: leftSwirlEl?.src,
      rightCircle: rightCircleEl?.src
    });
    const backImg = await loadImage(ticketBackEl.src);
    const forestImg = await loadImage(forestImgEl.src);
    const leftCircleImg = await loadImage(leftCircleEl.src);
    const leftSwirlImg = await loadImage(leftSwirlEl.src);
    const rightCircleImg = await loadImage(rightCircleEl.src);

    // ë² ì´ìŠ¤ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ë”ë¯¸ ì´ë¯¸ì§€ë¡œ ëŒ€ì²´
    if (!backImg){
      console.warn('âš ï¸ ë² ì´ìŠ¤ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨, ë”ë¯¸ ì´ë¯¸ì§€ë¡œ ëŒ€ì²´');
      // ê°„ë‹¨í•œ ë”ë¯¸ ì´ë¯¸ì§€ ìƒì„±
      const dummyImg = document.createElement('canvas');
      dummyImg.width = 400;
      dummyImg.height = 200;
      const ctx = dummyImg.getContext('2d');
      ctx.fillStyle = '#e6f3f3';
      ctx.fillRect(0, 0, 400, 200);
      ctx.fillStyle = '#3C6C71';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PORTATO TICKET', 200, 100);
      
      return dummyImg.toDataURL('image/png');
    }
    
    console.log('âœ… ë² ì´ìŠ¤ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ');

  // ============================================================
  // ğŸ¨ í‹°ì¼“ ìš”ì†Œ ë°°ì¹˜ ì„¤ì • - CSSì™€ ë™ì¼í•œ ê°’ ì‚¬ìš©!
  // ì—¬ê¸°ì„œ ê°’ì„ ìˆ˜ì •í•˜ë©´ CSSë„ í•¨ê»˜ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤.
  // ============================================================
  const PLACEMENT_CONFIG = {
    // ì¥ì†Œ ì´ë¯¸ì§€ ë°°ì¹˜
    placeImage: {
      left: 0.15,      // left: 15%
      bottom: 0.05,   // bottom: 5%
      width: 0.45,    // width: 45%
      height: 0.60    // height: 60% (CSSëŠ” autoì´ì§€ë§Œ JSì—ì„œëŠ” ë¹„ìœ¨ ê³„ì‚° í•„ìš”)
    },
    // ì™¼ìª½ ì›í˜• ë°°ì¹˜
    leftCircle: {
      left: 0.15,     // left: 15%
      top: 0.55,      // top: 55%
      width: 0.33     // width: 33%
    },
    // ì™¼ìª½ ìŠ¤ì™€ì¼ ë°°ì¹˜
    leftSwirl: {
      left: 0.14,     // left: 14%
      top: 0.65,      // top: 65%
      width: 0.22     // width: 22%
    },
    // ì˜¤ë¥¸ìª½ ì›í˜• ë°°ì¹˜
    rightCircle: {
      right: 0.15,    // right: 15%
      top: 0.55,      // top: 55%
      width: 0.33     // width: 33%
    }
  };

  // 12:7 ë¹„ìœ¨ë¡œ ìº”ë²„ìŠ¤ ìƒì„± (í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œì˜ ì‹¤ì œ ë Œë”ë§ í¬ê¸° ê°€ì ¸ì˜¤ê¸°)
  const ticketBackRect = ticketBackEl.getBoundingClientRect();
  const ticketBackRatio = 12 / 7;
  
  // 12:7 ë¹„ìœ¨ì„ ê°•ì œë¡œ ì ìš©
  let canvasW = Math.round(ticketBackRect.width);
  let canvasH = Math.round(canvasW / ticketBackRatio);
  
  // ìŠ¤ì¼€ì¼ ë¹„ìœ¨ ê³„ì‚° (DOM í¬ê¸° -> ìº”ë²„ìŠ¤ í¬ê¸°)
  // ì£¼ì˜: canvasHëŠ” 12:7 ë¹„ìœ¨ì— ì˜í•´ ticketBackRect.heightì™€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
  const scaleX = 1.0; // ê°€ë¡œëŠ” ë™ì¼
  const scaleY = canvasH / ticketBackRect.height; // ì„¸ë¡œë§Œ ë¹„ìœ¨ ì ìš©
  
  console.log('ğŸ” ë””ë²„ê·¸ ì •ë³´:');
  console.log('  ticketWrapRect:', ticketWrapRect.width, 'x', ticketWrapRect.height);
  console.log('  ticketBackRect:', ticketBackRect.width, 'x', ticketBackRect.height);
  console.log('  canvas í¬ê¸° (12:7 ê°•ì œ):', canvasW, 'x', canvasH);
  console.log('  ìŠ¤ì¼€ì¼ ë¹„ìœ¨:', scaleX, 'x', scaleY);

  // prepare canvas
  const cvs = document.createElement('canvas');
  cvs.width = canvasW;
  cvs.height = canvasH;
  const ctx = cvs.getContext('2d');

  // ìƒˆë¡œìš´ í‹°ì¼“ ë ˆì´ì–´ ìˆœì„œëŒ€ë¡œ ê·¸ë¦¬ê¸° (DOMì—ì„œ ì‹¤ì œ ìœ„ì¹˜ ê·¸ëŒ€ë¡œ ìº¡ì²˜)
  // 1. ticket_back.svg (ë°±ê·¸ë¼ìš´ë“œ) - 12:7 ë¹„ìœ¨ë¡œ ê·¸ë¦¬ê¸°
  if (backImg) {
    const x = 0;
    const y = 0;
    ctx.drawImage(backImg, x, y, canvasW, canvasH);
    console.log('âœ… í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ:', x, y, canvasW, canvasH);
  }
  
  // 2. ì¥ì†Œë³„ ì´ë¯¸ì§€ (forest_img.png ë“±) - DOM ìœ„ì¹˜ ìŠ¤ì¼€ì¼ ì ìš©
  if (forestImg) {
    const forestRect = forestImgEl.getBoundingClientRect();
    const x = (forestRect.left - ticketBackRect.left) * scaleX;
    const y = (forestRect.top - ticketBackRect.top) * scaleY;
    const w = forestRect.width * scaleX;
    const h = forestRect.height * scaleY;
    console.log('  forest: rect at', forestRect.left, forestRect.top, forestRect.width, 'x', forestRect.height, '-> canvas at', x, y, w, 'x', h);
    ctx.drawImage(forestImg, 0, 0, forestImg.naturalWidth, forestImg.naturalHeight, x, y, w, h);
  }
  
  // 3. left_circle.svg (ì™¼ìª½ ì›í˜•) - DOM ìœ„ì¹˜ ìŠ¤ì¼€ì¼ ì ìš©
  if (leftCircleImg) {
    const leftCircleRect = leftCircleEl.getBoundingClientRect();
    const x = (leftCircleRect.left - ticketBackRect.left) * scaleX;
    const y = (leftCircleRect.top - ticketBackRect.top) * scaleY;
    const w = leftCircleRect.width * scaleX;
    const h = leftCircleRect.height * scaleY;
    console.log('  leftCircle: rect at', leftCircleRect.left, leftCircleRect.top, leftCircleRect.width, 'x', leftCircleRect.height, '-> canvas at', x, y, w, 'x', h);
    ctx.drawImage(leftCircleImg, 0, 0, leftCircleImg.naturalWidth, leftCircleImg.naturalHeight, x, y, w, h);
  }
  
  // 4. left_swirl.svg (ì™¼ìª½ ìŠ¤ì™€ì¼) - DOM ìœ„ì¹˜ ìŠ¤ì¼€ì¼ ì ìš©
  if (leftSwirlImg) {
    const leftSwirlRect = leftSwirlEl.getBoundingClientRect();
    const x = (leftSwirlRect.left - ticketBackRect.left) * scaleX;
    const y = (leftSwirlRect.top - ticketBackRect.top) * scaleY;
    const w = leftSwirlRect.width * scaleX;
    const h = leftSwirlRect.height * scaleY;
    console.log('  leftSwirl: rect at', leftSwirlRect.left, leftSwirlRect.top, leftSwirlRect.width, 'x', leftSwirlRect.height, '-> canvas at', x, y, w, 'x', h);
    ctx.drawImage(leftSwirlImg, 0, 0, leftSwirlImg.naturalWidth, leftSwirlImg.naturalHeight, x, y, w, h);
  }
  
  // 5. right_circle.svg (ì˜¤ë¥¸ìª½ ì›í˜•) - DOM ìœ„ì¹˜ ìŠ¤ì¼€ì¼ ì ìš©
  if (rightCircleImg) {
    const rightCircleRect = rightCircleEl.getBoundingClientRect();
    const x = (rightCircleRect.left - ticketBackRect.left) * scaleX;
    const y = (rightCircleRect.top - ticketBackRect.top) * scaleY;
    const w = rightCircleRect.width * scaleX;
    const h = rightCircleRect.height * scaleY;
    console.log('  rightCircle: rect at', rightCircleRect.left, rightCircleRect.top, rightCircleRect.width, 'x', rightCircleRect.height, '-> canvas at', x, y, w, 'x', h);
    ctx.drawImage(rightCircleImg, 0, 0, rightCircleImg.naturalWidth, rightCircleImg.naturalHeight, x, y, w, h);
  }

  // draw draggable images at their current positions
  // get the draggable images currently in ticketContent DOM with their actual positions
  const draggableNodes = Array.from(ticketContent.querySelectorAll('.draggable-img'));
  console.log('ğŸ¨ ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ê°œìˆ˜:', draggableNodes.length);
  if (draggableNodes.length){
    // Get ticketContent position relative to ticketBackRect for accurate positioning
    const ticketContentRect = ticketContent.getBoundingClientRect();
    
    // Calculate offset of ticketContent relative to ticketBackRect
    const contentOffsetX = ticketContentRect.left - ticketBackRect.left;
    const contentOffsetY = ticketContentRect.top - ticketBackRect.top;
    
    for (const node of draggableNodes) {
      try {
        // Load the image
        const img = await loadImage(node.src);
        if (!img) continue;
        
        // Get current position and size from style
        const leftPercent = parseFloat(node.style.left) || 0;
        const topPercent = parseFloat(node.style.top) || 0;
        const widthPx = parseFloat(node.style.width) || node.naturalWidth || img.naturalWidth;
        const heightPx = parseFloat(node.style.height) || node.naturalHeight || img.naturalHeight;
        
        // Convert percentage to canvas coordinates
        // left/top are percentages relative to ticketContent
        // Account for transform: translate(-50%, -50%) by subtracting half width/height
        const actualLeft = (contentOffsetX + (leftPercent / 100) * ticketContentRect.width - (widthPx / 2)) * scaleX;
        const actualTop = (contentOffsetY + (topPercent / 100) * ticketContentRect.height - (heightPx / 2)) * scaleY;
        const actualW = widthPx * scaleX;
        const actualH = heightPx * scaleY;
        
        // Draw the image at its actual position on canvas
        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, 
                      actualLeft, actualTop, actualW, actualH);
      } catch (err) {
        console.warn('âš ï¸ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ì‹¤íŒ¨:', node.src, err);
      }
    }
  }

  console.log('ğŸ¨ í‹°ì¼“ ìº”ë²„ìŠ¤ ìƒì„± ì™„ë£Œ');
  
  // file:// í”„ë¡œí† ì½œì—ì„œ toDataURLì´ ë§‰í ìˆ˜ ìˆìœ¼ë¯€ë¡œ í•­ìƒ toBlob ì‚¬ìš©
  // CORS ë¬¸ì œ ë°©ì§€ë¥¼ ìœ„í•´ toBlobì„ ì§ì ‘ ì‚¬ìš©
  return new Promise((resolve, reject) => {
    try {
      cvs.toBlob((blob) => {
        if (!blob) {
          // toBlob ì‹¤íŒ¨ ì‹œ toDataURL ì‹œë„
          try {
            const dataURL = cvs.toDataURL('image/png');
            resolve(dataURL);
          } catch (dataURLError) {
            console.error('âŒ toBlobê³¼ toDataURL ëª¨ë‘ ì‹¤íŒ¨:', dataURLError);
            reject(new Error('ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨'));
          }
          return;
        }
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => {
          console.error('âŒ FileReader ì‹¤íŒ¨:', reader.error);
          reject(reader.error);
        };
        reader.readAsDataURL(blob);
      }, 'image/png');
    } catch (error) {
      console.warn('âš ï¸ toBlob í˜¸ì¶œ ì‹¤íŒ¨, toDataURL ì‹œë„:', error);
      try {
        const dataURL = cvs.toDataURL('image/png');
        resolve(dataURL);
      } catch (dataURLError) {
        reject(dataURLError);
      }
    }
  });
  
  } catch (error) {
    console.error('âŒ í‹°ì¼“ ìƒì„± ì˜¤ë¥˜:', error);
    throw error;
  }
}

// ì˜¤ë¥¸ìª½ í‹°ì¼“ë§Œ ìº¡ì³í•˜ëŠ” í•¨ìˆ˜
async function captureRightTicket() {
  try {
    console.log('ğŸ“¸ ì˜¤ë¥¸ìª½ í‹°ì¼“ ìº¡ì³ ì‹œì‘...');
    
    const ticketWrap = document.getElementById('ticketWrap');
    const ticketContent = document.getElementById('ticketContent');
    
    if (!ticketWrap || !ticketContent) {
      throw new Error('í‹°ì¼“ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }
    
    // í‹°ì¼“ ì „ì²´ ì˜ì—­ì˜ í¬ê¸°ì™€ ìœ„ì¹˜ ê³„ì‚°
    const wrapRect = ticketWrap.getBoundingClientRect();
    const contentRect = ticketContent.getBoundingClientRect();
    
    // ìº”ë²„ìŠ¤ ìƒì„± (í‹°ì¼“ ì „ì²´ í¬ê¸°)
    const canvas = document.createElement('canvas');
    canvas.width = wrapRect.width;
    canvas.height = wrapRect.height;
    const ctx = canvas.getContext('2d');
    
    // ìƒˆë¡œìš´ í‹°ì¼“ ì´ë¯¸ì§€ë“¤ ë¡œë“œ ì‹œë„
    try {
      const backImg = await loadImage(ticketBackEl.src);
      const forestImg = await loadImage(forestImgEl.src);
      const leftCircleImg = await loadImage(leftCircleEl.src);
      const leftSwirlImg = await loadImage(leftSwirlEl.src);
      const rightCircleImg = await loadImage(rightCircleEl.src);
      
      // ë°°ì¹˜ ì„¤ì • (composeTicketDataURLì™€ ë™ì¼)
      const PLACEMENT_CONFIG_RIGHT = {
        placeImage: { left: 0.15, bottom: 0.05, width: 0.45, height: 0.60 },
        leftCircle: { left: 0.15, top: 0.55, width: 0.33 },
        leftSwirl: { left: 0.14, top: 0.65, width: 0.22 },
        rightCircle: { right: 0.15, top: 0.55, width: 0.33 }
      };
      
      // ë ˆì´ì–´ ìˆœì„œëŒ€ë¡œ ê·¸ë¦¬ê¸° (í¬ê¸° ìµœì í™”)
      if (backImg) ctx.drawImage(backImg, 0, 0, canvas.width, canvas.height);
      
      // ì¥ì†Œë³„ ì´ë¯¸ì§€ - í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ì•ˆì—ë§Œ ë°°ì¹˜
      if (forestImg) {
        const p = PLACEMENT_CONFIG_RIGHT.placeImage;
        const forestW = Math.round(canvas.width * p.width);
        const forestH = Math.round(canvas.height * p.height);
        const forestX = Math.round(canvas.width * p.left);
        const forestY = Math.round(canvas.height * (1 - p.height - p.bottom));
        // ê²½ê³„ ê²€ì¦
        const maxX = canvas.width * 0.95;
        const actualW = Math.min(forestW, maxX - forestX);
        ctx.drawImage(forestImg, 0, 0, forestImg.naturalWidth, forestImg.naturalHeight, forestX, forestY, actualW, forestH);
      }
      
      // ì™¼ìª½ ì›í˜• - í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ì•ˆì—ë§Œ ë°°ì¹˜
      if (leftCircleImg) {
        const p = PLACEMENT_CONFIG_RIGHT.leftCircle;
        const leftW = Math.round(canvas.width * p.width);
        const leftH = Math.round(canvas.width * p.width * (leftCircleImg.naturalHeight / leftCircleImg.naturalWidth));
        const leftX = Math.round(canvas.width * p.left);
        const leftY = Math.round((canvas.height - leftH) / 2);
        // ê²½ê³„ ê²€ì¦
        const maxW = canvas.width * 0.90;
        const actualW = Math.min(leftW, maxW - leftX);
        const actualH = Math.round(actualW * (leftCircleImg.naturalHeight / leftCircleImg.naturalWidth));
        ctx.drawImage(leftCircleImg, 0, 0, leftCircleImg.naturalWidth, leftCircleImg.naturalHeight, leftX, leftY, actualW, actualH);
      }
      
      // ì™¼ìª½ ìŠ¤ì™€ì¼ - í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ì•ˆì—ë§Œ ë°°ì¹˜
      if (leftSwirlImg) {
        const p = PLACEMENT_CONFIG_RIGHT.leftSwirl;
        const leftW = Math.round(canvas.width * p.width);
        const leftH = Math.round(canvas.width * p.width * (leftSwirlImg.naturalHeight / leftSwirlImg.naturalWidth));
        const leftX = Math.round(canvas.width * p.left);
        const leftY = Math.round((canvas.height - leftH) / 2);
        // ê²½ê³„ ê²€ì¦
        const maxW = canvas.width * 0.90;
        const actualW = Math.min(leftW, maxW - leftX);
        const actualH = Math.round(actualW * (leftSwirlImg.naturalHeight / leftSwirlImg.naturalWidth));
        ctx.drawImage(leftSwirlImg, 0, 0, leftSwirlImg.naturalWidth, leftSwirlImg.naturalHeight, leftX, leftY, actualW, actualH);
      }
      
      // ì˜¤ë¥¸ìª½ ì›í˜• - í‹°ì¼“ ë°±ê·¸ë¼ìš´ë“œ ì•ˆì—ë§Œ ë°°ì¹˜
      if (rightCircleImg) {
        const p = PLACEMENT_CONFIG_RIGHT.rightCircle;
        const rightW = Math.round(canvas.width * p.width);
        const rightH = Math.round(canvas.width * p.width * (rightCircleImg.naturalHeight / rightCircleImg.naturalWidth));
        const rightX = Math.round(canvas.width * (1 - p.width - p.right));
        const rightY = Math.round((canvas.height - rightH) / 2);
        // ê²½ê³„ ê²€ì¦
        const maxX = canvas.width * 0.95;
        const actualW = Math.min(rightW, rightX);
        const actualH = Math.round(actualW * (rightCircleImg.naturalHeight / rightCircleImg.naturalWidth));
        ctx.drawImage(rightCircleImg, 0, 0, rightCircleImg.naturalWidth, rightCircleImg.naturalHeight, rightX, rightY, actualW, actualH);
      }
      
      console.log('âœ… ìƒˆë¡œìš´ í‹°ì¼“ ì´ë¯¸ì§€ë“¤ ë¡œë“œ ì„±ê³µ');
    } catch (error) {
      console.warn('âš ï¸ ìƒˆë¡œìš´ í‹°ì¼“ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨, ë°°ê²½ë§Œ ìƒì„±');
      // ë² ì´ìŠ¤ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ë°°ê²½ë§Œ ìƒì„±
      ctx.fillStyle = '#e6f3f3';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#3C6C71';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PORTATO', canvas.width/2, canvas.height/2);
    }
    
    // í‹°ì¼“ ìœ„ì˜ ì‚¬ìš©ì ì„ íƒ ì´ë¯¸ì§€ë“¤ ì¶”ê°€
    const leftImages = ticketContent.querySelectorAll('.draggable-img');
    console.log('ğŸ¨ ì™¼ìª½ ì´ë¯¸ì§€ë“¤ ì¶”ê°€:', leftImages.length);
    
    leftImages.forEach((img, index) => {
      try {
        const imgRect = img.getBoundingClientRect();
        const relativeX = imgRect.left - wrapRect.left;
        const relativeY = imgRect.top - wrapRect.top;
        
        // ì´ë¯¸ì§€ê°€ í‹°ì¼“ ì˜ì—­ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
        if (relativeX >= 0 && relativeY >= 0 && 
            relativeX + imgRect.width <= canvas.width && 
            relativeY + imgRect.height <= canvas.height) {
          
          // SVG ì´ë¯¸ì§€ì˜ ê²½ìš° ì§ì ‘ ê·¸ë¦¬ê¸°
          if (img.src.endsWith('.svg')) {
            ctx.fillStyle = '#3C6C71';
            ctx.font = '12px Arial';
            ctx.fillText(`ì´ë¯¸ì§€${index + 1}`, relativeX, relativeY + 15);
          }
        }
      } catch (error) {
        console.warn(`ì´ë¯¸ì§€ ${index + 1} ì²˜ë¦¬ ì‹¤íŒ¨:`, error);
      }
    });
    
    console.log('âœ… ì˜¤ë¥¸ìª½ í‹°ì¼“ ìº¡ì³ ì™„ë£Œ');
    return canvas.toDataURL('image/png');
    
  } catch (error) {
    console.error('âŒ ì˜¤ë¥¸ìª½ í‹°ì¼“ ìº¡ì³ ì‹¤íŒ¨:', error);
    throw error;
  }
}

/* UI actions */

// ğŸ”„ ìœ„ì¹˜ ì´ˆê¸°í™” í•¨ìˆ˜: ëª¨ë“  ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ë¥¼ ì´ˆê¸° ìœ„ì¹˜ë¡œ ë³µì›
function resetImagePositions() {
  const draggableImages = document.querySelectorAll('.draggable-img');
  console.log('ğŸ”„ ì´ë¯¸ì§€ ìœ„ì¹˜ ì´ˆê¸°í™” ì‹œì‘, ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€:', draggableImages.length);
  
  // ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ì´ˆê¸°í™”
  draggableImages.forEach((img, index) => {
    const initialLeft = img.dataset.initialLeft;
    const initialTop = img.dataset.initialTop;
    
    if (initialLeft && initialTop) {
      img.style.left = initialLeft;
      img.style.top = initialTop;
      console.log(`âœ… ì´ë¯¸ì§€ ${index + 1} ì´ˆê¸° ìœ„ì¹˜ë¡œ ë³µì›: left=${initialLeft}, top=${initialTop}`);
    } else {
      console.warn(`âš ï¸ ì´ë¯¸ì§€ ${index + 1}ì— ì´ˆê¸° ìœ„ì¹˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`);
    }
  });
  
  console.log('âœ… ëª¨ë“  ì´ë¯¸ì§€ ìœ„ì¹˜ ì´ˆê¸°í™” ì™„ë£Œ');
}

// ìœ„ì¹˜ ì´ˆê¸°í™” ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
if (btnReset) {
  btnReset.addEventListener('click', ()=> {
    console.log('ğŸ”„ ìœ„ì¹˜ ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ë¨');
    resetImagePositions();
  });
}

btnReselect.addEventListener('click', ()=> {
  // clear selections and return to index (or radial)
  localStorage.removeItem(SELECTION_KEY);
  localStorage.removeItem('portatoCurrentStep');
  location.href = 'index.html';
});

btnUseTicket.addEventListener('click', async ()=> {
  try {
    btnUseTicket.disabled = true;
    btnUseTicket.style.opacity = '.6';
    
    // left_circle íšŒì „ ì• ë‹ˆë©”ì´ì…˜ë§Œ ì¤‘ì§€ (ì›ë˜ ìˆë˜ ìš”ì†Œì´ë¯€ë¡œ ì¡´ì¬ëŠ” ìœ ì§€)
    if (leftCircleEl) {
      leftCircleEl.style.animationPlayState = 'paused';
    }
    
    // right_circle glow ì› ì™„ì „íˆ ìˆ¨ê¸°ê¸° (ê°•ì¡°ìš©ìœ¼ë¡œ ì¶”ê°€í•œ ìš”ì†Œì´ë¯€ë¡œ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€ + ì¡´ì¬ ìˆ¨ê¹€)
    if (rightCircleGlowEl) {
      rightCircleGlowEl.style.animationPlayState = 'paused'; // ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€
      rightCircleGlowEl.style.setProperty('display', 'none', 'important'); // ì™„ì „íˆ ìˆ¨ê¹€ (!importantë¡œ ê°•ì œ)
      rightCircleGlowEl.style.setProperty('opacity', '0', 'important'); // íˆ¬ëª…í•˜ê²Œ
      rightCircleGlowEl.style.setProperty('visibility', 'hidden', 'important'); // ì™„ì „íˆ ìˆ¨ê¹€
    }
    
    console.log('ğŸ« í‹°ì¼“ ì €ì¥ ë° ê³ ì • ì‹œì‘...');
    
    // ì˜¤ë¥¸ìª½ right_circle ì˜ì—­ì˜ ê·¸ë˜í”½ ë°°ì¹˜ ì •ë³´ ìˆ˜ì§‘
    const ticketContent = document.getElementById('ticketContent');
    const rightCircle = document.getElementById('rightCircle');
    const imagePositions = [];
    
    // right_circle ë‚´ë¶€ì˜ ëª¨ë“  ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ìœ„ì¹˜ ì •ë³´ ìˆ˜ì§‘
    const draggableImages = ticketContent.querySelectorAll('.draggable-img');
    
    console.log('ğŸ” ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ê°œìˆ˜:', draggableImages.length);
    
    draggableImages.forEach((img, index) => {
      // right_circle ë‚´ë¶€ì— ìˆëŠ” ì´ë¯¸ì§€ë§Œ ìˆ˜ì§‘
      const imgRect = img.getBoundingClientRect();
      const circleRect = rightCircle ? rightCircle.getBoundingClientRect() : null;
      
      if (circleRect) {
        // ì´ë¯¸ì§€ê°€ right_circleì™€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
        const isOverlapping = !(imgRect.right < circleRect.left || 
                                 imgRect.left > circleRect.right || 
                                 imgRect.bottom < circleRect.top || 
                                 imgRect.top > circleRect.bottom);
        
        if (isOverlapping) {
          // ì´ë¯¸ì§€ì˜ ì‹¤ì œ ìœ„ì¹˜ì™€ í¬ê¸°ë¥¼ í”½ì…€ë¡œ ê³„ì‚°
          const imgLeftPx = imgRect.left - circleRect.left;
          const imgTopPx = imgRect.top - circleRect.top;
          const imgWidthPx = imgRect.width;
          const imgHeightPx = imgRect.height;
          
          // right_circleì˜ í¬ê¸°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ ìœ„ì¹˜ ê³„ì‚° (0~1 ë²”ìœ„)
          const relativeLeft = imgLeftPx / circleRect.width;
          const relativeTop = imgTopPx / circleRect.height;
          const relativeWidth = imgWidthPx / circleRect.width;
          const relativeHeight = imgHeightPx / circleRect.height;
      
          imagePositions.push({
            index: index,
            // right_circle ê¸°ì¤€ ìƒëŒ€ ìœ„ì¹˜ (0~1 ë²”ìœ„)
            relativeLeft: relativeLeft,
            relativeTop: relativeTop,
            relativeWidth: relativeWidth,
            relativeHeight: relativeHeight,
            src: img.src,
            alt: img.alt,
            transform: img.style.transform || ''
          });
          
          console.log(`ğŸ“ right_circle ì´ë¯¸ì§€ ${index + 1} ìƒëŒ€ ìœ„ì¹˜: left=${relativeLeft.toFixed(3)}, top=${relativeTop.toFixed(3)}, size=${relativeWidth.toFixed(3)}x${relativeHeight.toFixed(3)}`);
        }
      }
    });
    
    // ëª¨ë“  ë“œë˜ê·¸ ë¹„í™œì„±í™”
    draggableImages.forEach(img => {
      img.style.pointerEvents = 'none';
      img.style.cursor = 'default';
      // ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì œê±°
      if (img._dragMouseDown) {
        img.removeEventListener('mousedown', img._dragMouseDown);
      }
    });
    
    console.log('âœ… ë“œë˜ê·¸ ë¹„í™œì„±í™” ì™„ë£Œ');
    
    // right_circle ì˜ì—­ì„ ì´ë¯¸ì§€ë¡œ ìº¡ì³ (html2canvas ì‚¬ìš© - ê°€ì¥ ì •í™•)
    let rightCircleImageDataURL = null;
    if (rightCircle && ticketContent && typeof html2canvas !== 'undefined') {
      try {
        const ticketWrapEl = document.getElementById('ticketWrap');
        if (!ticketWrapEl) {
          console.warn('âš ï¸ ticketWrap ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        } else {
          // right_circleì™€ ê·¸ë˜í”½ë§Œ ìº¡ì³ (ë°°ê²½ ì´ë¯¸ì§€ ì œì™¸)
          // ë°°ê²½ ì´ë¯¸ì§€ë“¤ ìˆ¨ê¸°ê¸° (ticket_back, forest_img, left_circle, left_swirl)
          const ticketBack = document.getElementById('ticketBack');
          const forestImgEl = document.getElementById('forestImg');
          const leftCircle = document.getElementById('leftCircle');
          const leftSwirl = document.getElementById('leftSwirl');
          
          const hiddenElements = [];
          [ticketBack, forestImgEl, leftCircle, leftSwirl].forEach(el => {
            if (el) {
              const originalDisplay = window.getComputedStyle(el).display;
              el.style.display = 'none';
              hiddenElements.push({ element: el, originalDisplay: originalDisplay });
            }
          });
          
          // í…ìŠ¤íŠ¸ ìš”ì†Œë“¤ë„ ìˆ¨ê¸°ê¸°
          const textElements = [];
          const allElements = ticketWrapEl.querySelectorAll('*');
          allElements.forEach(el => {
            if (el.tagName !== 'IMG') {
              const computedStyle = window.getComputedStyle(el);
              const zIndex = computedStyle.zIndex;
              const hasText = el.textContent && el.textContent.trim().length > 0;
              
              if ((zIndex === '150' || zIndex === '160' || parseInt(zIndex) === 150 || parseInt(zIndex) === 160) && hasText) {
                const originalVisibility = computedStyle.visibility;
                el.style.visibility = 'hidden';
                textElements.push({ element: el, originalVisibility: originalVisibility });
              }
            }
          });
          
          console.log(`ğŸ“ ${hiddenElements.length}ê°œì˜ ë°°ê²½ ì´ë¯¸ì§€ë¥¼ ìˆ¨ê¹€`);
          console.log(`ğŸ“ ${textElements.length}ê°œì˜ í…ìŠ¤íŠ¸ ìš”ì†Œë¥¼ ìˆ¨ê¹€`);
          
          // right_circle ì˜ì—­ì˜ ìœ„ì¹˜ë¥¼ oncloneì—ì„œ ê³„ì‚°í•˜ì—¬ ë” ì •í™•í•˜ê²Œ
          let rightCircleCropData = null;
          
          // í”„ë¡œí† ì½œ ê°ì§€ (file:// vs http/https)
          const isFileProtocol = window.location.protocol === 'file:';
          const isLocalhost = window.location.hostname === 'localhost' || 
                              window.location.hostname === '127.0.0.1';
          const isProduction = !isFileProtocol && !isLocalhost; // GitHub Pages ë“± í”„ë¡œë•ì…˜ í™˜ê²½
          
          // ì „ì²´ í‹°ì¼“ ìº¡ì³ (ë°°ê²½ ì´ë¯¸ì§€ì™€ í…ìŠ¤íŠ¸ ì—†ìŒ)
          const fullCanvas = await html2canvas(ticketWrapEl, {
            useCORS: !isFileProtocol, // http/httpsì—ì„œëŠ” true (GitHub Pagesì—ì„œ ì •ìƒ ì‘ë™)
            allowTaint: isFileProtocol, // file://ì—ì„œë§Œ true
            backgroundColor: null,
            scale: 2,
            logging: !isProduction, // í”„ë¡œë•ì…˜ì—ì„œëŠ” ë¡œê¹… ë¹„í™œì„±í™”
            onclone: (clonedDoc, element) => {
              // í´ë¡ ëœ ë¬¸ì„œì—ì„œ right_circle ìœ„ì¹˜ ê³„ì‚°
              const clonedRightCircle = clonedDoc.getElementById('rightCircle');
              const clonedTicketWrap = clonedDoc.getElementById('ticketWrap');
              
              if (clonedRightCircle && clonedTicketWrap) {
                const clonedRightCircleRect = clonedRightCircle.getBoundingClientRect();
                const clonedTicketWrapRect = clonedTicketWrap.getBoundingClientRect();
                
                const scale = 2;
                const cropX = (clonedRightCircleRect.left - clonedTicketWrapRect.left) * scale;
                const cropY = (clonedRightCircleRect.top - clonedTicketWrapRect.top) * scale;
                const cropW = clonedRightCircleRect.width * scale;
                const cropH = clonedRightCircleRect.height * scale;
                
                rightCircleCropData = { cropX, cropY, cropW, cropH };
                console.log(`ğŸ“ oncloneì—ì„œ ê³„ì‚°ëœ ì¢Œí‘œ: cropX=${cropX}, cropY=${cropY}, cropW=${cropW}, cropH=${cropH}`);
              }
            }
          });
          
          // ìˆ¨ê¸´ ìš”ì†Œë“¤ ë³µì›
          hiddenElements.forEach(({ element, originalDisplay }) => {
            element.style.display = originalDisplay;
          });
          textElements.forEach(({ element, originalVisibility }) => {
            element.style.visibility = originalVisibility;
          });
          console.log(`ğŸ“ ëª¨ë“  ìš”ì†Œ ë³µì› ì™„ë£Œ`);
          
          // right_circle ì˜ì—­ë§Œ ì˜ë¼ë‚´ê¸°
          let cropX, cropY, cropW, cropH;
          
          if (rightCircleCropData) {
            // oncloneì—ì„œ ê³„ì‚°ëœ ì¢Œí‘œ ì‚¬ìš© (ê°€ì¥ ì •í™•)
            cropX = rightCircleCropData.cropX;
            cropY = rightCircleCropData.cropY;
            cropW = rightCircleCropData.cropW;
            cropH = rightCircleCropData.cropH;
            console.log(`âœ… onclone ì¢Œí‘œ ì‚¬ìš©`);
          } else {
            // fallback: getBoundingClientRect ì‚¬ìš©
            const rightCircleRect = rightCircle.getBoundingClientRect();
            const ticketWrapRect = ticketWrapEl.getBoundingClientRect();
            const scale = 2;
            cropX = (rightCircleRect.left - ticketWrapRect.left) * scale;
            cropY = (rightCircleRect.top - ticketWrapRect.top) * scale;
            cropW = rightCircleRect.width * scale;
            cropH = rightCircleRect.height * scale;
            console.log(`âš ï¸ getBoundingClientRect ì¢Œí‘œ ì‚¬ìš© (fallback)`);
          }
          
          console.log(`ğŸ“ ìµœì¢… ìº¡ì²˜ ì¢Œí‘œ: cropX=${cropX}, cropY=${cropY}, cropW=${cropW}, cropH=${cropH}`);
          
          const cropCanvas = document.createElement('canvas');
          cropCanvas.width = cropW;
          cropCanvas.height = cropH;
          const cropCtx = cropCanvas.getContext('2d');
          
          cropCtx.drawImage(fullCanvas, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);
          
          // toDataURL ì‹¤íŒ¨ ì‹œ toBlob ì‚¬ìš©
          try {
            rightCircleImageDataURL = cropCanvas.toDataURL('image/png');
          } catch (dataURLError) {
            console.warn('âš ï¸ toDataURL ì‹¤íŒ¨, toBlobìœ¼ë¡œ ëŒ€ì²´:', dataURLError);
            rightCircleImageDataURL = await new Promise((resolve, reject) => {
              cropCanvas.toBlob((blob) => {
                if (!blob) {
                  reject(new Error('toBlob ì‹¤íŒ¨'));
                  return;
                }
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              }, 'image/png');
            });
          }
          console.log(`âœ… right_circle ì˜ì—­ ìº¡ì³ ì™„ë£Œ (ë°°ê²½ ì´ë¯¸ì§€ ì œì™¸, ì˜¤ì§ ì›ê³¼ ê·¸ë˜í”½ë§Œ)`);
          console.log(`ğŸ“Š ìº¡ì³ëœ ì´ë¯¸ì§€ ë°ì´í„° í¬ê¸°: ${(rightCircleImageDataURL.length / 1024).toFixed(2)}KB`);
        }
      } catch (error) {
        console.error('âŒ right_circle ìº¡ì³ ì‹¤íŒ¨:', error);
        console.warn('âš ï¸ file:// í”„ë¡œí† ì½œì—ì„œëŠ” ìº¡ì²˜ê°€ ì œí•œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¡œì»¬ ì„œë²„(http://localhost) ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.');
        // fallback ë°©ì‹ ì œê±° - file:// í”„ë¡œí† ì½œì—ì„œ ë„ˆë¬´ ë§ì€ CORS ì—ëŸ¬ ë°œìƒ
        // ì²« ë²ˆì§¸ ë°©ì‹ì´ ì‹¤íŒ¨í•˜ë©´ rightCircleImageëŠ” nullë¡œ ì €ì¥
        rightCircleImageDataURL = null;
        
        /* fallback ë°©ì‹ ë¹„í™œì„±í™” - CORS ë¬¸ì œë¡œ ì¸í•´ ì œê±°
        try {
          const ticketWrapEl = document.getElementById('ticketWrap');
          if (!ticketWrapEl) {
            console.warn('âš ï¸ ticketWrap ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ fallbackë„ ì‹¤íŒ¨í•©ë‹ˆë‹¤.');
          } else {
            // ê²°ê³¼ í˜ì´ì§€ëŠ” ì „í˜€ ê±´ë“œë¦¬ì§€ ì•Šê³ , ì„ì‹œ ì»¨í…Œì´ë„ˆì—ì„œë§Œ ì‘ì—…
            const rightCircleRect = rightCircle.getBoundingClientRect();
          
          // right_circleë§Œ í¬í•¨í•˜ëŠ” ì„ì‹œ ì»¨í…Œì´ë„ˆ ìƒì„± (í™”ë©´ ë°–ì— ë°°ì¹˜)
          const tempContainer = document.createElement('div');
          tempContainer.style.cssText = `
            position: fixed;
            left: -9999px;
            top: -9999px;
            width: ${rightCircleRect.width}px;
            height: ${rightCircleRect.height}px;
            overflow: visible;
            background: transparent;
          `;
          
          // right_circle ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ ë° í´ë¡  ìƒì„±
          const rightCircleImg = new Image();
          await new Promise((resolve, reject) => {
            rightCircleImg.onload = resolve;
            rightCircleImg.onerror = reject;
            rightCircleImg.src = rightCircle.src;
          });
          
          // right_circle ë°°ê²½ ì´ë¯¸ì§€ë¥¼ blob URLë¡œ ë³€í™˜í•˜ì—¬ CORS ë¬¸ì œ í•´ê²°
          let rightCircleBgSrc = rightCircle.src;
          try {
            const bgCanvas = document.createElement('canvas');
            bgCanvas.width = rightCircle.naturalWidth || rightCircle.width;
            bgCanvas.height = rightCircle.naturalHeight || rightCircle.height;
            const bgCtx = bgCanvas.getContext('2d');
            bgCtx.drawImage(rightCircle, 0, 0);
            
            rightCircleBgSrc = await new Promise((resolve, reject) => {
              bgCanvas.toBlob((blob) => {
                if (blob) {
                  resolve(URL.createObjectURL(blob));
                } else {
                  reject(new Error('toBlob ì‹¤íŒ¨'));
                }
              }, 'image/png');
            });
          } catch (bgBlobError) {
            console.warn('âš ï¸ rightCircle ë°°ê²½ blob ë³€í™˜ ì‹¤íŒ¨, ì›ë³¸ ì‚¬ìš©:', bgBlobError);
            rightCircleBgSrc = rightCircle.src;
          }
          
          // right_circle ë°°ê²½ ì´ë¯¸ì§€ ìƒì„± ë° ë¡œë“œ ëŒ€ê¸°
          const rightCircleBg = document.createElement('img');
          await new Promise((resolve, reject) => {
            rightCircleBg.onload = resolve;
            rightCircleBg.onerror = reject;
            rightCircleBg.src = rightCircleBgSrc;
          });
          
          rightCircleBg.style.cssText = `
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
          `;
          tempContainer.appendChild(rightCircleBg);
          
          // ticketWrap ê¸°ì¤€ ìœ„ì¹˜ ê³„ì‚°ì„ ìœ„í•´ ì‹¤ì œ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
          const ticketWrapRect = ticketWrapEl.getBoundingClientRect();
          
          console.log(`ğŸ“Š ìº¡ì²˜ ì •ë³´: right_circle í¬ê¸°=${rightCircleRect.width}x${rightCircleRect.height}, ë“œë˜ê·¸ ì´ë¯¸ì§€ ê°œìˆ˜=${draggableImages.length}`);
          console.log(`ğŸ“ right_circle ìœ„ì¹˜: left=${rightCircleRect.left}, top=${rightCircleRect.top}`);
          
          // right_circle ë‚´ë¶€ì˜ ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ë“¤ ë³µì‚¬ (ì •í™•í•œ ìœ„ì¹˜ ìœ ì§€)
          let copiedImageCount = 0;
          for (const img of draggableImages) {
            const imgRect = img.getBoundingClientRect();
            console.log(`ğŸ” ì´ë¯¸ì§€ ${img.alt || img.src} ìœ„ì¹˜: left=${imgRect.left}, top=${imgRect.top}, size=${imgRect.width}x${imgRect.height}`);
            
            const isOverlapping = !(imgRect.right < rightCircleRect.left || 
                                   imgRect.left > rightCircleRect.right || 
                                   imgRect.bottom < rightCircleRect.top || 
                                   imgRect.top > rightCircleRect.bottom);
            
            console.log(`  ê²¹ì¹¨ ì—¬ë¶€: ${isOverlapping ? 'âœ… ê²¹ì¹¨' : 'âŒ ê²¹ì¹˜ì§€ ì•ŠìŒ'}`);
            
            if (isOverlapping) {
              // ì´ë¯¸ì§€ì˜ ì‹¤ì œ ìŠ¤íƒ€ì¼ ì†ì„± ì½ê¸° (í¼ì„¼íŠ¸ ê°’)
              const imgStyleLeft = img.style.left || window.getComputedStyle(img).left;
              const imgStyleTop = img.style.top || window.getComputedStyle(img).top;
              const imgStyleTransform = img.style.transform || window.getComputedStyle(img).transform;
              const imgStyleWidth = img.style.width || window.getComputedStyle(img).width;
              const imgStyleHeight = img.style.height || window.getComputedStyle(img).height;
              
              // í¼ì„¼íŠ¸ ê°’ì„ ì‹¤ì œ í”½ì…€ ê°’ìœ¼ë¡œ ë³€í™˜ (ticketWrap ê¸°ì¤€)
              let imgLeftPx, imgTopPx;
              
              if (imgStyleLeft.includes('%')) {
                // í¼ì„¼íŠ¸ ê°’ì¸ ê²½ìš° ticketWrap ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°
                const percentLeft = parseFloat(imgStyleLeft);
                imgLeftPx = (ticketWrapRect.width * percentLeft / 100);
              } else {
                // í”½ì…€ ê°’ì¸ ê²½ìš°
                imgLeftPx = parseFloat(imgStyleLeft) || 0;
              }
              
              if (imgStyleTop.includes('%')) {
                // í¼ì„¼íŠ¸ ê°’ì¸ ê²½ìš° ticketWrap ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°
                const percentTop = parseFloat(imgStyleTop);
                imgTopPx = (ticketWrapRect.height * percentTop / 100);
              } else {
                // í”½ì…€ ê°’ì¸ ê²½ìš°
                imgTopPx = parseFloat(imgStyleTop) || 0;
              }
              
              // right_circle ê¸°ì¤€ ìƒëŒ€ ìœ„ì¹˜ë¡œ ë³€í™˜
              const ticketContentRect = ticketContent.getBoundingClientRect();
              const rightCircleInTicketWrapLeft = rightCircleRect.left - ticketContentRect.left;
              const rightCircleInTicketWrapTop = rightCircleRect.top - ticketContentRect.top;
              
              // ì‹¤ì œ ì´ë¯¸ì§€ ì¤‘ì‹¬ ìœ„ì¹˜ ê³„ì‚° (transform ê³ ë ¤)
              let actualImgLeftPx = imgLeftPx;
              let actualImgTopPx = imgTopPx;
              
              if (imgStyleTransform && imgStyleTransform.includes('translate')) {
                // translate(-50%, -50%) ê°™ì€ ê²½ìš° ì¤‘ì‹¬ ê¸°ì¤€ì´ë¯€ë¡œ ì¡°ì • í•„ìš”
                const match = imgStyleTransform.match(/translate\(([^)]+)\)/);
                if (match) {
                  const translateValues = match[1].split(',').map(v => v.trim());
                  const translateX = translateValues[0];
                  const translateY = translateValues[1] || translateValues[0];
                  
                  if (translateX.includes('%')) {
                    const percentX = parseFloat(translateX);
                    actualImgLeftPx += (ticketWrapRect.width * percentX / 100);
                  } else {
                    actualImgLeftPx += parseFloat(translateX) || 0;
                  }
                  
                  if (translateY.includes('%')) {
                    const percentY = parseFloat(translateY);
                    actualImgTopPx += (ticketWrapRect.height * percentY / 100);
                  } else {
                    actualImgTopPx += parseFloat(translateY) || 0;
                  }
                }
              }
              
              // right_circle ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ ìœ„ì¹˜ ê³„ì‚°
              const relativeLeftPx = actualImgLeftPx - rightCircleInTicketWrapLeft;
              const relativeTopPx = actualImgTopPx - rightCircleInTicketWrapTop;
              
              // ì´ë¯¸ì§€ë¥¼ blob URLë¡œ ë³€í™˜í•˜ì—¬ CORS ë¬¸ì œ í•´ê²°
              let imgBlobURL = img.src;
              try {
                // ì´ë¯¸ì§€ë¥¼ canvasë¡œ ê·¸ë ¤ì„œ blobìœ¼ë¡œ ë³€í™˜
                const imgCanvas = document.createElement('canvas');
                imgCanvas.width = img.naturalWidth || img.width;
                imgCanvas.height = img.naturalHeight || img.height;
                const imgCtx = imgCanvas.getContext('2d');
                imgCtx.drawImage(img, 0, 0);
                
                // blob URLë¡œ ë³€í™˜ (ë¹„ë™ê¸° Promiseë¡œ ì²˜ë¦¬)
                imgBlobURL = await new Promise((resolve, reject) => {
                  imgCanvas.toBlob((blob) => {
                    if (blob) {
                      resolve(URL.createObjectURL(blob));
                    } else {
                      reject(new Error('toBlob ì‹¤íŒ¨'));
                    }
                  }, 'image/png');
                });
              } catch (blobError) {
                console.warn(`âš ï¸ ì´ë¯¸ì§€ blob ë³€í™˜ ì‹¤íŒ¨, ì›ë³¸ ì‚¬ìš©: ${img.src}`, blobError);
                // blob ë³€í™˜ ì‹¤íŒ¨ ì‹œ ì›ë³¸ ì‚¬ìš©
                imgBlobURL = img.src;
              }
              
              // ì´ë¯¸ì§€ í´ë¡  ìƒì„±
              const imgClone = document.createElement('img');
              imgClone.src = imgBlobURL;
              imgClone.alt = img.alt || '';
              
              // ìŠ¤íƒ€ì¼ ë³µì‚¬ (ì •í™•í•œ ìœ„ì¹˜ ìœ ì§€)
              imgClone.style.position = 'absolute';
              imgClone.style.left = `${relativeLeftPx}px`;
              imgClone.style.top = `${relativeTopPx}px`;
              imgClone.style.width = imgStyleWidth;
              imgClone.style.height = imgStyleHeight;
              imgClone.style.transform = imgStyleTransform;
              
              // ë‹¤ë¥¸ ìŠ¤íƒ€ì¼ë„ ë³µì‚¬
              if (img.style.zIndex) imgClone.style.zIndex = img.style.zIndex;
              if (img.style.opacity) imgClone.style.opacity = img.style.opacity;
              
              // ì´ë¯¸ì§€ ë¡œë“œ ëŒ€ê¸°
              await new Promise((resolve) => {
                if (imgClone.complete && imgClone.naturalWidth > 0) {
                  resolve();
                } else {
                  imgClone.onload = () => {
                    console.log(`  âœ… ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ: ${img.src}`);
                    resolve();
                  };
                  imgClone.onerror = () => {
                    console.warn(`  âš ï¸ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${img.src}`);
                    resolve(); // ì—ëŸ¬ê°€ ë‚˜ë„ ì§„í–‰
                  };
                }
              });
              
              tempContainer.appendChild(imgClone);
              copiedImageCount++;
              console.log(`âœ… ê·¸ë˜í”½ ${copiedImageCount} ë³µì‚¬ ì™„ë£Œ (ìœ„ì¹˜: ${relativeLeftPx.toFixed(1)}px, ${relativeTopPx.toFixed(1)}px): ${img.alt || img.src}`);
            }
          }
          
          console.log(`ğŸ“Š ì´ ${copiedImageCount}ê°œì˜ ê·¸ë˜í”½ì´ ì„ì‹œ ì»¨í…Œì´ë„ˆì— ë³µì‚¬ë¨`);
          
          if (copiedImageCount === 0) {
            console.warn('âš ï¸ ë³µì‚¬ëœ ê·¸ë˜í”½ì´ ì—†ìŠµë‹ˆë‹¤! draggableImagesê°€ right_circleì™€ ê²¹ì¹˜ì§€ ì•ŠëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤.');
          }
          
          document.body.appendChild(tempContainer);
          
          // ë””ë²„ê¹…: tempContainerì˜ ìì‹ ìš”ì†Œ í™•ì¸
          const containerChildren = tempContainer.children;
          console.log(`ğŸ“¦ tempContainer ìì‹ ìš”ì†Œ ê°œìˆ˜: ${containerChildren.length}`);
          for (let i = 0; i < containerChildren.length; i++) {
            const child = containerChildren[i];
            console.log(`  ${i + 1}. ${child.tagName} - src: ${child.src || 'N/A'}, style: ${child.style.cssText}`);
          }
          
          // ì´ë¯¸ì§€ë“¤ì´ ëª¨ë‘ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸° (ë” ê¸´ ëŒ€ê¸° ì‹œê°„)
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // ëª¨ë“  ì´ë¯¸ì§€ê°€ ì‹¤ì œë¡œ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
          const allImages = tempContainer.querySelectorAll('img');
          let loadedCount = 0;
          for (const img of allImages) {
            if (img.complete && img.naturalWidth > 0) {
              loadedCount++;
              console.log(`  âœ… ì´ë¯¸ì§€ ë¡œë“œ í™•ì¸: ${img.src} (${img.naturalWidth}x${img.naturalHeight})`);
            } else {
              console.warn(`  âš ï¸ ì´ë¯¸ì§€ ë¡œë“œ ì•ˆë¨: ${img.src}`);
            }
          }
          console.log(`ğŸ“Š ì´ë¯¸ì§€ ë¡œë“œ ìƒíƒœ: ${loadedCount}/${allImages.length}ê°œ ë¡œë“œë¨`);
          
          // html2canvasë¡œ right_circleë§Œ ìº¡ì²˜ (íˆ¬ëª… ë°°ê²½)
          console.log('ğŸ“¸ html2canvas ìº¡ì²˜ ì‹œì‘...');
          
          // ì´ë¯¸ì§€ë“¤ì˜ CORS ì„¤ì • í™•ì¸ ë° crossOrigin ì„¤ì •
          const allImgs = tempContainer.querySelectorAll('img');
          allImgs.forEach(img => {
            if (!img.crossOrigin) {
              img.crossOrigin = 'anonymous';
              // crossOriginì„ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ë¡œë“œí•´ì•¼ í•¨
              const src = img.src;
              img.src = '';
              img.src = src;
            }
          });
          
          // ì´ë¯¸ì§€ ì¬ë¡œë“œ ëŒ€ê¸°
          await new Promise(resolve => {
            let loadedCount = 0;
            const totalImgs = allImgs.length;
            if (totalImgs === 0) {
              resolve();
              return;
            }
            allImgs.forEach(img => {
              if (img.complete) {
                loadedCount++;
                if (loadedCount === totalImgs) resolve();
              } else {
                img.onload = img.onerror = () => {
                  loadedCount++;
                  if (loadedCount === totalImgs) resolve();
                };
              }
            });
          });
          
          const canvas = await html2canvas(tempContainer, {
            useCORS: true,
            allowTaint: false, // blob URL ì‚¬ìš©í•˜ë¯€ë¡œ falseë¡œ ìœ ì§€ (íˆ¬ëª… ë°°ê²½ ìœ ì§€)
            backgroundColor: null, // íˆ¬ëª… ë°°ê²½
            scale: 2, // ê³ í•´ìƒë„ ìº¡ì²˜
            logging: true, // ë””ë²„ê¹…ì„ ìœ„í•´ ë¡œê¹… í™œì„±í™”
            width: rightCircleRect.width,
            height: rightCircleRect.height,
            onclone: (clonedDoc) => {
              // í´ë¡ ëœ ë¬¸ì„œì—ì„œ ì´ë¯¸ì§€ í™•ì¸
              const clonedContainer = clonedDoc.querySelector(`[style*="left: -9999px"]`);
              if (clonedContainer) {
                const clonedImages = clonedContainer.querySelectorAll('img');
                console.log(`ğŸ“‹ í´ë¡ ëœ ì»¨í…Œì´ë„ˆì˜ ì´ë¯¸ì§€ ê°œìˆ˜: ${clonedImages.length}`);
              }
            }
          });
          
          console.log(`ğŸ“¸ ìº¡ì²˜ ì™„ë£Œ - ìº”ë²„ìŠ¤ í¬ê¸°: ${canvas.width}x${canvas.height}`);
          
          // ì„ì‹œ ì»¨í…Œì´ë„ˆ ì¦‰ì‹œ ì œê±° (ê²°ê³¼ í˜ì´ì§€ì—ëŠ” ì˜í–¥ ì—†ìŒ)
          document.body.removeChild(tempContainer);
          
          // ì´ë¯¸ì§€ ë°ì´í„° URLë¡œ ë³€í™˜ (íˆ¬ëª… ë°°ê²½ ìœ ì§€)
          // allowTaintê°€ trueì—¬ë„ CORS ì„¤ì •ëœ ì´ë¯¸ì§€ëŠ” toDataURL ê°€ëŠ¥
          try {
            rightCircleImageDataURL = canvas.toDataURL('image/png');
          } catch (dataURLError) {
            // toDataURLì´ ì‹¤íŒ¨í•˜ë©´ toBlob ì‚¬ìš©
            console.warn('âš ï¸ toDataURL ì‹¤íŒ¨, toBlobìœ¼ë¡œ ëŒ€ì²´:', dataURLError);
            rightCircleImageDataURL = await new Promise((resolve, reject) => {
              canvas.toBlob((blob) => {
                if (!blob) {
                  reject(new Error('toBlob ì‹¤íŒ¨'));
                  return;
                }
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              }, 'image/png');
            });
          }
          console.log(`âœ… right_circle ì˜ì—­ ìº¡ì³ ì™„ë£Œ (íˆ¬ëª… ë°°ê²½, right_circleì™€ ê·¸ë˜í”½ë§Œ, ê²°ê³¼ í˜ì´ì§€ ë³€ê²½ ì—†ìŒ)`);
          console.log(`ğŸ“Š ìº¡ì³ëœ ì´ë¯¸ì§€ ë°ì´í„° í¬ê¸°: ${(rightCircleImageDataURL.length / 1024).toFixed(2)}KB`);
          }
        } catch (fallbackError) {
          console.error('âŒ fallback ìº¡ì³ ë°©ì‹ë„ ì‹¤íŒ¨:', fallbackError);
          // ìº¡ì³ ì‹¤íŒ¨í•´ë„ ì§„í–‰
        }
        */
      }
    } else if (!rightCircle) {
      console.warn('âš ï¸ rightCircle ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    } else if (!ticketContent) {
      console.warn('âš ï¸ ticketContent ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    } else {
      console.warn('âš ï¸ html2canvas ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
    
    // ì•„ì¹´ì´ë¸Œì— ì €ì¥
    let archive = [];
    try { 
      archive = JSON.parse(localStorage.getItem(ARCHIVE_KEY) || '[]'); 
    } catch(e){ 
      archive = []; 
    }
    
    // ì´ë¯¸ì§€ ë°ì´í„° URL ìœ íš¨ì„± ê²€ì‚¬
    let validRightCircleImage = null;
    if (rightCircleImageDataURL) {
      // ë°ì´í„° URL í˜•ì‹ í™•ì¸ (data:imageë¡œ ì‹œì‘í•˜ëŠ”ì§€)
      if (rightCircleImageDataURL.startsWith('data:image/')) {
        // ìµœì†Œ ê¸¸ì´ í™•ì¸ (ë„ˆë¬´ ì§§ìœ¼ë©´ ì˜ë¦° ê²ƒ)
        if (rightCircleImageDataURL.length > 100) {
          validRightCircleImage = rightCircleImageDataURL;
          console.log(`âœ… ì´ë¯¸ì§€ ë°ì´í„° URL ìœ íš¨ì„± í™•ì¸: ${(rightCircleImageDataURL.length / 1024).toFixed(2)}KB`);
        } else {
          console.warn('âš ï¸ ì´ë¯¸ì§€ ë°ì´í„° URLì´ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤ (ì˜ë¦° ê°€ëŠ¥ì„±):', rightCircleImageDataURL.length);
        }
      } else {
        console.warn('âš ï¸ ì´ë¯¸ì§€ ë°ì´í„° URL í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤:', rightCircleImageDataURL.substring(0, 50));
      }
    } else {
      console.warn('âš ï¸ rightCircleImageDataURLì´ ì—†ìŠµë‹ˆë‹¤.');
    }
    
    const entry = { 
      id: `ticket_${Date.now()}`, 
      timestamp: Date.now(),
      imagePositions: imagePositions, // í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€
      selections: selections || {},
      // right_circle ì˜ì—­ì„ ìº¡ì³í•œ ì´ë¯¸ì§€ ë°ì´í„° URL ì €ì¥ (ìœ íš¨í•œ ê²½ìš°ë§Œ)
      rightCircleImage: validRightCircleImage
    };
    
    // ìƒˆ í•­ëª© í¬ê¸° ì˜ˆì¸¡
    const newEntrySize = new Blob([JSON.stringify(entry)]).size;
    
    // ìš©ëŸ‰ ê´€ë¦¬: í•„ìš”ì‹œ ì˜¤ë˜ëœ ì´ë¯¸ì§€ ì••ì¶•
    await manageArchiveStorage(newEntrySize);
    
    archive.push(entry);
    
    // ì €ì¥ ì‹œë„
    try {
      const archiveString = JSON.stringify(archive);
      // ì €ì¥ ì „ì— ë¬¸ìì—´ ê¸¸ì´ í™•ì¸
      const archiveSize = new Blob([archiveString]).size;
      console.log(`ğŸ“Š ì•„ì¹´ì´ë¸Œ ì €ì¥ ì‹œë„: ${(archiveSize / 1024 / 1024).toFixed(2)}MB`);
      
      localStorage.setItem(ARCHIVE_KEY, archiveString);
      console.log('âœ… ì•„ì¹´ì´ë¸Œì— ì €ì¥ ì™„ë£Œ:', entry.id);
      
      // ì €ì¥ í›„ ê²€ì¦
      const savedArchive = JSON.parse(localStorage.getItem(ARCHIVE_KEY) || '[]');
      const savedEntry = savedArchive.find(e => e.id === entry.id);
      if (savedEntry && savedEntry.rightCircleImage && entry.rightCircleImage) {
        if (savedEntry.rightCircleImage.length === entry.rightCircleImage.length) {
          console.log('âœ… ì €ì¥ëœ ì´ë¯¸ì§€ ë°ì´í„° ê²€ì¦ ì™„ë£Œ');
        } else {
          console.warn('âš ï¸ ì €ì¥ëœ ì´ë¯¸ì§€ ë°ì´í„°ê°€ ì˜ë ¸ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:', {
            ì›ë³¸: entry.rightCircleImage.length,
            ì €ì¥ë¨: savedEntry.rightCircleImage.length
          });
        }
      }
    } catch (storageError) {
      // ì €ì¥ ì‹¤íŒ¨ ì‹œ (ìš©ëŸ‰ ì´ˆê³¼) ë” ë§ì€ ì´ë¯¸ì§€ ì••ì¶•
      console.warn('âš ï¸ ì €ì¥ ì‹¤íŒ¨, ì¶”ê°€ ì••ì¶• ì‹œë„...', storageError);
      
      // ë” ê°•í•œ ì••ì¶• (í’ˆì§ˆ 0.5)
      archive.sort((a, b) => a.timestamp - b.timestamp);
      for (let i = 0; i < archive.length; i++) {
        const item = archive[i];
        if (item.rightCircleImage) {
          const compressed = await compressImage(item.rightCircleImage, 0.5);
          item.rightCircleImage = compressed;
          item.compressed = true;
          
          try {
            localStorage.setItem(ARCHIVE_KEY, JSON.stringify(archive));
            console.log('âœ… ì¶”ê°€ ì••ì¶• í›„ ì €ì¥ ì„±ê³µ');
            break;
          } catch (e) {
            // ê³„ì† ì••ì¶•
          }
        }
      }
      
      // ìµœì¢… ì €ì¥ ì‹œë„
      try {
        localStorage.setItem(ARCHIVE_KEY, JSON.stringify(archive));
        console.log('âœ… ìµœì¢… ì €ì¥ ì™„ë£Œ');
        
        // ì•„ì¹´ì´ë¸Œ í˜ì´ì§€ì— ìƒˆë¡œê³ ì¹¨ ì•Œë¦¼ (BroadcastChannel ì‚¬ìš©)
        try {
          const channel = new BroadcastChannel('portato_archive');
          channel.postMessage({ type: 'archive_updated', timestamp: Date.now() });
          channel.close();
          console.log('ğŸ“¢ ì•„ì¹´ì´ë¸Œ í˜ì´ì§€ì— ì—…ë°ì´íŠ¸ ì•Œë¦¼ ì „ì†¡');
        } catch (channelError) {
          console.warn('âš ï¸ BroadcastChannel ì‚¬ìš© ì‹¤íŒ¨:', channelError);
        }
        
        // localStorage ë³€ê²½ ì´ë²¤íŠ¸ë¥¼ ìœ„í•œ íŠ¸ë¦¬ê±° (storage ì´ë²¤íŠ¸ëŠ” ë‹¤ë¥¸ íƒ­ì—ì„œë§Œ ë°œìƒí•˜ë¯€ë¡œ ì§ì ‘ íŠ¸ë¦¬ê±°)
        // storage ì´ë²¤íŠ¸ëŠ” ë‹¤ë¥¸ íƒ­/ìœˆë„ìš°ì—ì„œë§Œ ë°œìƒí•˜ë¯€ë¡œ, ì§ì ‘ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ì—†ìŒ
        // ëŒ€ì‹  íŠ¹ë³„í•œ í‚¤ë¥¼ ì„¤ì •í•˜ì—¬ ë³€ê²½ì„ ì•Œë¦¼
        try {
          localStorage.setItem('portato_archive_updated', Date.now().toString());
          // ì¦‰ì‹œ ì‚­ì œí•˜ì—¬ ë‹¤ìŒ ë³€ê²½ì„ ê°ì§€í•  ìˆ˜ ìˆë„ë¡ í•¨
          setTimeout(() => {
            localStorage.removeItem('portato_archive_updated');
          }, 100);
        } catch (e) {
          console.warn('âš ï¸ ì—…ë°ì´íŠ¸ íŠ¸ë¦¬ê±° ì„¤ì • ì‹¤íŒ¨:', e);
        }
      } catch (finalError) {
        console.error('âŒ ì €ì¥ ì‹¤íŒ¨ - ìš©ëŸ‰ì´ ë„ˆë¬´ í½ë‹ˆë‹¤:', finalError);
        alert('ì €ì¥ì†Œ ìš©ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ì¼ë¶€ ì˜¤ë˜ëœ í•­ëª©ì„ ì‚­ì œí•´ì£¼ì„¸ìš”.');
      }
    }
    
    // ë²„íŠ¼ ìˆ¨ê¸°ê¸°
    btnUseTicket.style.display = 'none';
    btnReset.style.display = 'none';
    
    // í‹°ì¼“ ë°œê¸‰ í›„: í‘¸í„° ë‹¤ì‹œ ë³´ì´ê¸°
    const siteFooter = document.querySelector('.site-footer');
    if (siteFooter) {
      siteFooter.style.display = 'block';
      console.log('âœ… í‘¸í„° í‘œì‹œ (í‹°ì¼“ ë°œê¸‰ ì™„ë£Œ)');
    }
    
    // í—¤ë”ë§Œ ìˆ¨ê¸°ê¸° (ì„œë¸Œ í…ìŠ¤íŠ¸ëŠ” ìƒˆë¡œìš´ ê²ƒìœ¼ë¡œ êµì²´)
    const titleBox = document.querySelector('.title-box');
    const resultSub = document.querySelector('.result-sub');
    if (titleBox) {
      titleBox.style.display = 'none';
    }
    // ê¸°ì¡´ ì„œë¸Œ í…ìŠ¤íŠ¸ëŠ” ìˆ¨ê¸°ê¸° (ìƒˆë¡œìš´ ì„œë¸Œ í…ìŠ¤íŠ¸ë¡œ êµì²´)
    if (resultSub) {
      resultSub.style.display = 'none';
    }
    
    // íŒì—… í‘œì‹œ
    const popup = document.createElement('div');
    popup.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(51, 110, 116, 0.7);
      color: #EBFEB3;
      padding: 2vw 4vw;
      border-radius: 1.5vw;
      border: 2px solid #F5FCD9;
      font-size: clamp(2vw, 3.5vmin, 3vw);
      font-weight: 700;
      z-index: 3000;
      opacity: 0;
      transition: opacity 0.5s ease;
      box-shadow: 0 8px 30px rgba(0,0,0,0.3);
    `;
    popup.textContent = 'í‹°ì¼“ì´ ë°œê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤.';
    document.body.appendChild(popup);
    
    // í˜ì´ë“œì¸
    setTimeout(() => {
      popup.style.opacity = '1';
    }, 100);
    
    // 2ì´ˆ í›„ í˜ì´ë“œì•„ì›ƒ
    setTimeout(() => {
      popup.style.opacity = '0';
      setTimeout(() => {
        popup.remove();
      }, 500);
    }, 2000);
    
    // ì„œë¸Œ í…ìŠ¤íŠ¸ í‘œì‹œ (ê³„ì† í‘œì‹œ - ì¦‰ì‹œ í‘œì‹œ)
    // ê¸°ì¡´ì— ê°™ì€ IDê°€ ìˆìœ¼ë©´ ì œê±°
    const existingSubText = document.getElementById('resultSubText');
    if (existingSubText) {
      existingSubText.remove();
    }
    
    const subText = document.createElement('p');
    subText.textContent = 'ë‹¹ì‹ ì˜ ì„ íƒìœ¼ë¡œ ì´ë£¨ì–´ì§„ í¬ë¥´íƒ€í†  ê³µì—°ì€ ì˜†ì˜ ì•„ì¹´ì´ë¸Œ í˜ì´ì§€ì— ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.';
    subText.id = 'resultSubText';
    subText.style.cssText = `
      position: fixed;
      top: 8vh;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(235, 254, 179, 0.9);
      font-size: clamp(1.2vw, 2vmin, 1.8vw);
      text-align: center;
      z-index: 3000;
      padding: 1.5vw 3vw;
      width: auto;
      max-width: 80vw;
      font-weight: 400;
      pointer-events: none;
      background: rgba(60, 108, 113, 0.3);
      border-radius: 1.5vw;
      box-sizing: border-box;
    `;
    document.body.appendChild(subText);
    console.log('âœ… ì„œë¸Œ í…ìŠ¤íŠ¸ ì¶”ê°€ë¨:', subText);
    
    // í‹°ì¼“ ìœ„ì¹˜ ì¡°ì • (ì„œë¸Œ í…ìŠ¤íŠ¸ ì•„ë˜ë¡œ ë‚´ë¦¬ê¸°)
    const ticketWrapEl = document.getElementById('ticketWrap');
    const mainApp = document.querySelector('.app');
    if (ticketWrapEl && mainApp) {
      // main.appì˜ padding-topì„ ì¦ê°€ì‹œì¼œì„œ í‹°ì¼“ì´ ì„œë¸Œ í…ìŠ¤íŠ¸ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ë„ë¡
      mainApp.style.paddingTop = '15vh';
      mainApp.style.transition = 'padding-top 0.3s ease';
      // í‹°ì¼“ ì¶”ê°€ ì—¬ë°±
      ticketWrapEl.style.marginTop = '4vh';
      ticketWrapEl.style.transition = 'margin-top 0.3s ease';
    }
    
    // ë°±ê·¸ë¼ìš´ë“œ ì´ë¯¸ì§€ ë³€ê²½
    const bgLayer = document.getElementById('bgLayer');
    if (bgLayer) {
      bgLayer.style.backgroundImage = `url("${resolvePath('result/background_get.png')}")`;
    }
    const bgDiv = document.querySelector('.bg');
    if (bgDiv) {
      bgDiv.style.backgroundImage = `url("${resolvePath('result/background_get.png')}")`;
    }
    
    // ì•„ì¹´ì´ë¸Œ í˜ì´ì§€ ê°€ê¸° ë²„íŠ¼ ì¶”ê°€ (ìˆ¨ê¹€)
    const archiveBtn = document.createElement('a');
    archiveBtn.href = 'archive.html';
    archiveBtn.textContent = 'ì•„ì¹´ì´ë¸Œ ë³´ê¸°';
    archiveBtn.style.cssText = `
      position: fixed;
      bottom: 8vh;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(60, 108, 113, 0.6);
      color: rgba(235, 254, 179, 0.9);
      padding: 1vw 2vw;
      border-radius: 1vw;
      border: 1px solid rgba(245, 252, 217, 0.5);
      font-size: clamp(1vw, 1.8vmin, 1.5vw);
      text-decoration: none;
      z-index: 2000;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
      display: none;
    `;
    archiveBtn.onmouseover = () => {
      archiveBtn.style.background = 'rgba(60, 108, 113, 0.8)';
      archiveBtn.style.transform = 'translateX(-50%) translateY(-2px)';
    };
    archiveBtn.onmouseout = () => {
      archiveBtn.style.background = 'rgba(60, 108, 113, 0.6)';
      archiveBtn.style.transform = 'translateX(-50%) translateY(0)';
    };
    document.body.appendChild(archiveBtn);
    
  } catch(err){
    console.error('âŒ í‹°ì¼“ ì €ì¥ ì˜¤ë¥˜:', err);
    alert('í‹°ì¼“ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
    btnUseTicket.disabled = false;
    btnUseTicket.style.opacity = '1';
  }
});

if (btnDownload) {
  btnDownload.addEventListener('click', async ()=>{
    try {
      btnDownload.disabled = true;
      const dataURL = await composeTicketDataURL();
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = `portato_ticket_${Date.now()}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      btnDownload.disabled = false;
    } catch(e){
      console.error(e);
      alert('ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨');
      btnDownload.disabled = false;
    }
  });
}

function showQRForDataURL(dataURL){
  // use Google Chart API to render QR of the dataURL (note: dataURL can be long; using it directly may exceed length limits for very large images)
  // better approach: store dataURL in archive and generate QR to a short URL â€” but here we encode the dataURI (may be long). We'll encode only a short JSON pointer if needed.
  // We'll create a small object URL by saving dataURL in localStorage under a unique key and create a QR that references a tiny "viewer" page with that key as param.
  const key = `portato_ticket_temp_${Date.now()}`;
  try { localStorage.setItem(key, dataURL); } catch(e){ /* storage may be full */ }
  // viewer.html?key=... is not implemented here; instead we'll encode a small viewer token using location origin + current path + '#ticket:' + key
  const ticketPointer = `${location.origin}${location.pathname}#${key}`;
  // Google Charts QR URL (size 160x160)
  const qrSrc = `https://chart.googleapis.com/chart?cht=qr&chs=240x240&chl=${encodeURIComponent(ticketPointer)}`;
  qrImg.src = qrSrc;
  qrArea.style.display = 'flex';
}

/* ë“œë˜ê·¸ ì•ˆë‚´ íˆ´íŒ */
(function initDragTooltip() {
  let tooltipShown = false;
  let tooltipTimeout = null;
  let hideTimeout = null;
  
  // íˆ´íŒ ìš”ì†Œ ìƒì„±
  const tooltip = document.createElement('div');
  tooltip.className = 'drag-tooltip';
  tooltip.textContent = 'ì› ì•ˆì˜ ê·¸ë˜í”½ì„ ë“œë˜ê·¸í•´ ë°°ì¹˜ë¥¼ ë°”ê¿”ë³´ì„¸ìš”';
  document.body.appendChild(tooltip);
  
  // íˆ´íŒ í‘œì‹œ í•¨ìˆ˜
  function showTooltip(x, y) {
    if (tooltipShown) return;
    
    tooltip.style.left = x + 'px';
    tooltip.style.top = y + 'px';
    tooltip.classList.remove('hide');
    tooltip.classList.add('show');
    
    // ì˜¤ë¥¸ìª½ ì› ê¸€ë¡œìš° ê°•ì¡° íš¨ê³¼ ì¶”ê°€
    const rightCircleGlow = document.querySelector('.right-circle-glow');
    if (rightCircleGlow) {
      rightCircleGlow.classList.add('tooltip-active');
    }
    
    // 5ì´ˆ í›„ ìë™ ìˆ¨ê¹€
    if (hideTimeout) clearTimeout(hideTimeout);
    hideTimeout = setTimeout(() => {
      hideTooltip();
    }, 5000);
  }
  
  // íˆ´íŒ ìˆ¨ê¹€ í•¨ìˆ˜
  function hideTooltip() {
    // ì¦‰ì‹œ ìˆ¨ê¹€ ì²˜ë¦¬ (ì• ë‹ˆë©”ì´ì…˜ ëŒ€ê¸° ì—†ì´)
    tooltip.classList.remove('show');
    tooltip.classList.add('hide');
    tooltip.style.display = 'none';
    tooltipShown = true;
    
    // ì˜¤ë¥¸ìª½ ì› ê¸€ë¡œìš° ê°•ì¡° íš¨ê³¼ ì œê±°
    const rightCircleGlow = document.querySelector('.right-circle-glow');
    if (rightCircleGlow) {
      rightCircleGlow.classList.remove('tooltip-active');
    }
    
    // íƒ€ì„ì•„ì›ƒ ì •ë¦¬
    if (tooltipTimeout) {
      clearTimeout(tooltipTimeout);
      tooltipTimeout = null;
    }
    if (hideTimeout) {
      clearTimeout(hideTimeout);
      hideTimeout = null;
    }
  }
  
  // ë§ˆìš°ìŠ¤ ì´ë™ ê°ì§€
  let firstMouseMove = true;
  
  document.addEventListener('mousemove', (e) => {
    // ì²« ë²ˆì§¸ ë§ˆìš°ìŠ¤ ì´ë™ì—ì„œë§Œ íˆ´íŒ í‘œì‹œ
    if (firstMouseMove && !tooltipShown) {
      firstMouseMove = false;
      
      // ì•½ê°„ì˜ ì§€ì—° í›„ í‘œì‹œ (í˜ì´ì§€ ë¡œë“œ ì§í›„ê°€ ì•„ë‹Œ ì‚¬ìš©ì ì˜ë„ì ì¸ ë§ˆìš°ìŠ¤ ì´ë™ ê°ì§€)
      if (tooltipTimeout) clearTimeout(tooltipTimeout);
      tooltipTimeout = setTimeout(() => {
        // ë§ˆìš°ìŠ¤ ì»¤ì„œ ìœ„ì¹˜ì—ì„œ ì•½ê°„ ìœ„ìª½ì— í‘œì‹œ
        const offsetX = 0; // ì»¤ì„œ ì¤‘ì‹¬
        const offsetY = -20; // ì»¤ì„œ ìœ„ìª½ 20px
        showTooltip(e.clientX + offsetX, e.clientY + offsetY);
      }, 300);
    }
    
    // íˆ´íŒì´ í‘œì‹œëœ ìƒíƒœì—ì„œ ë§ˆìš°ìŠ¤ ì´ë™ ì‹œ íˆ´íŒ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
    if (tooltip.classList.contains('show')) {
      const offsetX = 0;
      const offsetY = -20;
      tooltip.style.left = (e.clientX + offsetX) + 'px';
      tooltip.style.top = (e.clientY + offsetY) + 'px';
    }
  });
  
  // ë“œë˜ê·¸ ì‹œì‘ ì‹œ íˆ´íŒ ìˆ¨ê¹€ (ì´ë²¤íŠ¸ ìœ„ì„ ì‚¬ìš©)
  document.addEventListener('mousedown', (e) => {
    const draggableImg = e.target.closest('.draggable-img');
    if (draggableImg) {
      // ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ í´ë¦­ ì‹œ ì¦‰ì‹œ íˆ´íŒ ìˆ¨ê¹€
      if (tooltip.classList.contains('show') || tooltip.style.display !== 'none') {
        hideTooltip();
      }
    }
  }, true); // capture phaseì—ì„œ ì‹¤í–‰í•˜ì—¬ ë” ë¹ ë¥´ê²Œ ì²˜ë¦¬
  
  // í‹°ì¼“ ë°œê¸‰ ë²„íŠ¼ í´ë¦­ ì‹œ íˆ´íŒ ìˆ¨ê¹€
  const btnUseTicket = document.getElementById('btnUseTicket');
  if (btnUseTicket) {
    btnUseTicket.addEventListener('click', () => {
      hideTooltip();
    });
  }
})();

/* main init */
(async function init(){
  try {
    console.log('=== result.html ì´ˆê¸°í™” ì‹œì‘ ===');
    console.log('ticketContent ìš”ì†Œ:', ticketContent);
    console.log('selections ê°ì²´:', selections);
    
    // ì´ˆê¸° ìƒíƒœ (ë“œë˜ê·¸ ë‹¨ê³„): í‘¸í„° ìˆ¨ê¸°ê¸°
    const siteFooter = document.querySelector('.site-footer');
    if (siteFooter) {
      siteFooter.style.display = 'none';
      console.log('âœ… í‘¸í„° ìˆ¨ê¹€ (ë“œë˜ê·¸ ë‹¨ê³„)');
    }
    
    // GitHub Pages í˜¸í™˜: HTMLì˜ img íƒœê·¸ src ê²½ë¡œ ìˆ˜ì • (GitHub Pagesì—ì„œë§Œ)
    if (window.location.hostname.includes('github.io')) {
      const ticketImageIds = ['ticketBack', 'forestImg', 'leftCircle', 'leftSwirl', 'rightCircle', 'btnReset'];
      ticketImageIds.forEach(imgId => {
        const imgEl = document.getElementById(imgId);
        if (imgEl) {
          const originalSrc = imgEl.getAttribute('src');
          if (originalSrc && !originalSrc.startsWith('http') && !originalSrc.startsWith('data:')) {
            const resolvedPath = resolvePath(originalSrc);
            imgEl.src = resolvedPath;
            console.log(`ğŸ”„ ${imgId} ê²½ë¡œ ìˆ˜ì •: ${originalSrc} â†’ ${resolvedPath}`);
          }
        }
      });
      
      // CSS background ì´ë¯¸ì§€ë„ ìˆ˜ì •
      const bgElements = [document.querySelector('.bg'), document.getElementById('bgLayer')];
      bgElements.forEach(el => {
        if (el) {
          const bgImage = window.getComputedStyle(el).backgroundImage;
          if (bgImage && bgImage !== 'none' && bgImage.includes('result/')) {
            const urlMatch = bgImage.match(/url\(["']?([^"']+)["']?\)/);
            if (urlMatch && urlMatch[1] && !urlMatch[1].startsWith('http')) {
              const resolvedPath = resolvePath(urlMatch[1]);
              el.style.backgroundImage = `url("${resolvedPath}")`;
              console.log(`ğŸ”„ ë°°ê²½ ì´ë¯¸ì§€ ê²½ë¡œ ìˆ˜ì •: ${urlMatch[1]} â†’ ${resolvedPath}`);
            }
          }
        }
      });
    }
    
    // ì¥ì†Œì— ë”°ë¥¸ ë°°ê²½ ì´ë¯¸ì§€ ì„¤ì • (JavaScriptì—ì„œ ë™ì ìœ¼ë¡œ ì„¤ì •í•˜ëŠ” ê²½ìš°ë§Œ resolvePath ì‚¬ìš©)
    if (selections.place && forestImgEl) {
      const backgroundImage = PLACE_BACKGROUNDS[selections.place] || PLACE_BACKGROUNDS['forest'];
      forestImgEl.src = resolvePath(backgroundImage);
      console.log('ğŸ¨ ë°°ê²½ ì´ë¯¸ì§€ ì„¤ì •:', resolvePath(backgroundImage));
    }
    
    // glow ì› ì´ˆê¸° í¬ê¸° ì„¤ì • (ì´ë¯¸ì§€ ë¡œë“œ ì „ì—ë„ ì´ˆê¸° í¬ê¸° í‘œì‹œ)
    if (rightCircleGlowEl) {
      setTimeout(() => {
        updateRightCircleGlowSize();
      }, 100);
    }
    
    // ë¡œë”© ì‹œì‘
    console.log('ğŸš€ ë¡œë”© í™”ë©´ ì‹œì‘');
    showLoading();
    console.log('ğŸ“Š ì§„í–‰ë¥  ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘');
    simulateLoadingProgress(10, 300);
    
  // build preview UI from selections - ì£¼ì„ ì²˜ë¦¬ (init í•¨ìˆ˜ì—ì„œ ì§ì ‘ ì´ë¯¸ì§€ ìƒì„±í•¨)
    // console.log('buildPreview() í•¨ìˆ˜ í˜¸ì¶œ ì‹œì‘');
    // const loaded = await buildPreview();
    // console.log('buildPreview() í•¨ìˆ˜ ì™„ë£Œ, ê²°ê³¼:', loaded);
    
    // ë¡œë”© ì§„í–‰: 60% â†’ 90%
    simulateLoadingProgress(90, 500);
    
    // fallback ë©”ì‹œì§€ ë¹„í™œì„±í™” (ì´ë¯¸ì§€ í‘œì‹œë¥¼ ìœ„í•´)
  console.log('fallback ë©”ì‹œì§€ ë¹„í™œì„±í™” - ì´ë¯¸ì§€ í‘œì‹œ ìš°ì„ ');
  
  // ì‚¬ìš©ì ì„ íƒ ë°ì´í„° í™•ì¸ ë° ë¡œê·¸
  console.log('=== ì‚¬ìš©ì ì„ íƒ ë°ì´í„° í™•ì¸ ===');
  console.log('ì „ì²´ selections:', selections);
  console.log('selections.place:', selections.place);
  console.log('selections.mood:', selections.mood);
  console.log('selections.flow:', selections.flow);
  console.log('selections.extras:', selections.extras);
  console.log('selections.instruments:', selections.instruments);
  
  // ì„ íƒëœ ê°’ë“¤ ìˆ˜ì§‘
  const selectedValues = [];
  if (selections.place) selectedValues.push(selections.place);
  if (selections.mood) selectedValues.push(selections.mood);
  if (selections.flow) selectedValues.push(selections.flow);
  if (selections.extras) selectedValues.push(selections.extras);
  if (selections.instruments && Array.isArray(selections.instruments)) {
    selectedValues.push(...selections.instruments.slice(0, 3));
  }
  
  console.log('ìµœì¢… ì„ íƒëœ ê°’ë“¤:', selectedValues);
  
  // ticketContent ìš”ì†Œ ì¡´ì¬ í™•ì¸
  console.log('=== ticketContent ìš”ì†Œ í™•ì¸ ===');
  console.log('ticketContent ìš”ì†Œ:', ticketContent);
  console.log('ticketContent ì¡´ì¬ ì—¬ë¶€:', !!ticketContent);
  if (ticketContent) {
    console.log('ticketContent í˜„ì¬ innerHTML:', ticketContent.innerHTML);
    console.log('ticketContent ìŠ¤íƒ€ì¼:', window.getComputedStyle(ticketContent));
  }
  
  // ì‚¬ìš©ì ì„ íƒì— ë”°ë¥¸ ì‹¤ì œ ì´ë¯¸ì§€ í‘œì‹œ
  console.log('=== ì‚¬ìš©ì ì„ íƒì— ë”°ë¥¸ ì‹¤ì œ ì´ë¯¸ì§€ í‘œì‹œ ì‹œì‘ ===');
  
  // ========================================
  // ğŸ“ í‹°ì¼“ ì˜ì—­ ê²½ê³„ ê³„ì‚° (ë” ì •í™•í•œ ì˜ì—­ ì„¤ì •)
  // ========================================
  function calculateTicketBoundary() {
    const ticketLeft = document.querySelector('.ticket-left');
    const ticketRight = document.querySelector('.ticket-right');
    
    if (!ticketLeft || !ticketRight) {
      console.warn('í‹°ì¼“ ì˜ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
      return { left: null, right: null };
    }
    
    const leftRect = ticketLeft.getBoundingClientRect();
    const rightRect = ticketRight.getBoundingClientRect();
    const containerRect = ticketContent.getBoundingClientRect();
    
    // ì»¨í…Œì´ë„ˆ ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ì  ìœ„ì¹˜ ê³„ì‚°
    const leftBoundary = {
      left: (leftRect.left - containerRect.left) / containerRect.width * 100,
      right: (leftRect.right - containerRect.left) / containerRect.width * 100,
      top: (leftRect.top - containerRect.top) / containerRect.height * 100,
      bottom: (leftRect.bottom - containerRect.top) / containerRect.height * 100
    };
    
    const rightBoundary = {
      left: (rightRect.left - containerRect.left) / containerRect.width * 100,
      right: (rightRect.right - containerRect.left) / containerRect.width * 100,
      top: (rightRect.top - containerRect.top) / containerRect.height * 100,
      bottom: (rightRect.bottom - containerRect.top) / containerRect.height * 100
    };
    
    console.log('ğŸ¯ í‹°ì¼“ ì˜ì—­ ê²½ê³„:', { leftBoundary, rightBoundary });
    return { left: leftBoundary, right: rightBoundary };
  }

  // ========================================
  // ğŸ“ ê°œë³„ ì´ë¯¸ì§€ ìœ„ì¹˜ ì„¤ì • (í‹°ì¼“ ê¸°ì¤€ %)
  // ========================================
  const IMAGE_POSITIONS = {
    // ì™¼ìª½ ì´ë¯¸ì§€ë“¤ (ë§¤ìš° ë„“ê²Œ ë¶„ì‚° - 4ë¶„ë©´ ëŠë‚Œ)
    left: [
      { x: 8, y: 20 },   // ì¢Œìƒë‹¨ - ë” ì™¼ìª½ìœ¼ë¡œ
      { x: 30, y: 20 },  // ìš°ìƒë‹¨ - ë” ì˜¤ë¥¸ìª½ìœ¼ë¡œ
      { x: 8, y: 50 },   // ì¢Œí•˜ë‹¨ - ë” ì•„ë˜ë¡œ
      { x: 30, y: 50 },  // ìš°í•˜ë‹¨ - ë” ì•„ë˜ë¡œ
      { x: 19, y: 35 },  // ì¤‘ì•™
      { x: 35, y: 35 },  // ì¤‘ì•™-ìš°
      { x: 42, y: 35 }   // í‹°ì¼“ ì¤‘ì•™ì„  ê·¼ì²˜
    ],
    
    // ì˜¤ë¥¸ìª½ ì´ë¯¸ì§€ë“¤ (4ê°œ ê·¸ë˜í”½ ìœ„ì¹˜ ìœ ì§€, ì•…ê¸° 3ê°œ ì„¸ë¡œì¶• ì¤‘ì•™ì •ë ¬ + ê°„ê²© ë„“í˜)
    right: [
      { x: 3, y: 25 },   // 1ì‚¬ë¶„ë©´ (ìš°ìƒë‹¨) - ê°„ê²© ë„“í˜
      { x: 17, y: 25 },  // 2ì‚¬ë¶„ë©´ (ì¢Œìƒë‹¨) - ê°„ê²© ë„“í˜
      { x: 3, y: 50 },   // 4ì‚¬ë¶„ë©´ (ìš°í•˜ë‹¨) - ê°„ê²© ë„“í˜
      { x: 17, y: 50 },  // 3ì‚¬ë¶„ë©´ (ì¢Œí•˜ë‹¨) - ê°„ê²© ë„“í˜
      { x: 19, y: 37 },  // ì¤‘ì•™ (ticketright.svg ì¤‘ì‹¬)
      { x: 8, y: 55 },   // ì•…ê¸° 1 - ì„¸ë¡œì¶• ì¤‘ì•™ì •ë ¬ (y: 55) + ê°„ê²© ë„“í˜
      { x: 12, y: 55 },  // ì•…ê¸° 2 - ì„¸ë¡œì¶• ì¤‘ì•™ì •ë ¬ (y: 55) + ê°„ê²© ë„“í˜
      { x: 16, y: 55 }   // ì•…ê¸° 3 - ì„¸ë¡œì¶• ì¤‘ì•™ì •ë ¬ (y: 55) + ê°„ê²© ë„“í˜
    ]
  };
  
  // ì‚¬ìš©ì ì„ íƒì— ë”°ë¥¸ í…ìŠ¤íŠ¸ ìƒì„± í•¨ìˆ˜
  function generateUserText() {
    const placeLabels = {
      'lawn': 'ì”ë””ë°­',
      'forest': 'ìˆ²ì†',
      'valley': 'ê³„ê³¡',
      'sea': 'ë°”ë‹·ê°€'
    };
    
    const moodLabels = {
      'baroque': 'ì •êµí•œ ì„ ìœ¨',
      'romantic': 'ê°•ë ¬í•œ ê°ì •',
      'impression': 'ëª½í™˜ì  ìŒìƒ‰',
      'post': 'ììœ ë¡œìš´ í˜•ì‹'
    };
    
    const flowLabels = {
      'recline': 'í¸ì•ˆíˆ ëˆ„ì›Œ',
      'lounge': 'ììœ ë¡­ê²Œ ì•‰ì•„',
      'settle': 'ì¢Œì„ì—ì„œ ëª°ì…',
      'wander': 'ê°€ë³ê²Œ ëŒì•„ë‹¤ë‹ˆë©°'
    };
    
    const extrasLabels = {
      'dialogue': 'ì—°ì£¼ìì™€ ëŒ€í™”',
      'refresh': 'ë‹¤ê³¼ ì‹œê°„',
      'play': 'ìŒì•… í”Œë ˆì´ì¡´',
      'fire': 'ë¶ˆë¹› ë§ˆë‹¹'
    };
    
    // ì„ íƒëœ ê°’ë“¤ ê°€ì ¸ì˜¤ê¸°
    const place = placeLabels[selections.place] || 'ì„ íƒëœ ì¥ì†Œ';
    const mood = moodLabels[selections.mood] || 'ì„ íƒëœ ë¬´ë“œ';
    const flow = flowLabels[selections.flow] || 'ì„ íƒëœ ìì„¸';
    const extras = extrasLabels[selections.extras] || 'ì„ íƒëœ ê²½í—˜';
    
    // ì•…ê¸°ë“¤ ê°€ì ¸ì˜¤ê¸° ë° ì¡°ì‚¬ ì²˜ë¦¬
    const instruments = selections.instruments || [];
    
    // ì•…ê¸° í•œê¸€ëª…ì„ ì¤„ì„ë§ë¡œ ë³€í™˜
    function getInstrumentAbbreviation(koreanName) {
      const abbreviationMap = {
        'íŠ¸ëŸ¼í«': 'Tp.',
        'íŠ¸ëŸ¼ë³¸': 'Trb.',
        'í˜¸ë¥¸': 'Hn.',
        'í´ë¼ë¦¬ë„·': 'Cl.',
        'í”Œë£»': 'Fl.',
        'ë°”ì´ì˜¬ë¦°': 'Vn.',
        'ë¹„ì˜¬ë¼': 'Vla.',
        'ì²¼ë¡œ': 'Vc.',
        'ì½˜íŠ¸ë¼ë² ì´ìŠ¤': 'Cb.'
      };
      return abbreviationMap[koreanName] || koreanName;
    }
    
    function getKoreanParticle(word) {
      const lastChar = word[word.length - 1];
      const hasBatchim = (lastChar.charCodeAt(0) - 0xAC00) % 28 !== 0;
      return hasBatchim ? 'ì´' : 'ê°€';
    }
    
    // ì¡°ì‚¬ ìë™ ì„ íƒ í•¨ìˆ˜ë“¤
    function getEseParticle(word) {
      const lastChar = word[word.length - 1];
      const hasBatchim = (lastChar.charCodeAt(0) - 0xAC00) % 28 !== 0;
      return hasBatchim ? 'ì—ì„œ' : 'ì—ì„œ'; // 'ì—ì„œ'ëŠ” ë°›ì¹¨ ìœ ë¬´ì™€ ê´€ê³„ì—†ì´ ë™ì¼
    }
    
    function getEulParticle(word) {
      const lastChar = word[word.length - 1];
      const hasBatchim = (lastChar.charCodeAt(0) - 0xAC00) % 28 !== 0;
      return hasBatchim ? 'ì„' : 'ë¥¼';
    }
    
    function getRoParticle(word) {
      const lastChar = word[word.length - 1];
      const hasBatchim = (lastChar.charCodeAt(0) - 0xAC00) % 28 !== 0;
      return hasBatchim ? 'ë¡œ' : 'ìœ¼ë¡œ';
    }
    
    let instrumentText;
    let particle;
    
    if (instruments.length > 0) {
      if (instruments.length === 1) {
        // ì•…ê¸°ê°€ í•˜ë‚˜ì¼ ë•Œ - ì¤„ì„ë§ë¡œ ë³€í™˜ (ì¡°ì‚¬ëŠ” ì›ë˜ í•œê¸€ëª…ìœ¼ë¡œ ê²°ì •)
        instrumentText = getInstrumentAbbreviation(instruments[0]);
        particle = getKoreanParticle(instruments[0]); // ì¡°ì‚¬ëŠ” í•œê¸€ëª…ìœ¼ë¡œ ê²°ì •
      } else {
        // ì•…ê¸°ê°€ ì—¬ëŸ¬ ê°œì¼ ë•ŒëŠ” ë§ˆì§€ë§‰ ì•…ê¸°ì—ë§Œ ì¡°ì‚¬ ì ìš© - ì¤„ì„ë§ë¡œ ë³€í™˜
        const lastInstrument = instruments[instruments.length - 1];
        const otherInstruments = instruments.slice(0, -1);
        particle = getKoreanParticle(lastInstrument); // ì¡°ì‚¬ëŠ” í•œê¸€ëª…ìœ¼ë¡œ ê²°ì •
        // ëª¨ë“  ì•…ê¸°ë¥¼ ì¤„ì„ë§ë¡œ ë³€í™˜
        instrumentText = otherInstruments.map(inst => getInstrumentAbbreviation(inst)).join(' ') + ' ' + getInstrumentAbbreviation(lastInstrument);
      }
    } else {
      instrumentText = 'ì„ íƒëœ ì•…ê¸°';
      particle = 'ê°€';
    }
    
    // ========================================
    // ğŸ“ í‹°ì¼“ ì •ë³´ í…ìŠ¤íŠ¸ ìƒì„±
    // ========================================
    function generateTicketInfo() {
      // ê° ì‚¬ë¶„ë©´ ì„ íƒì˜ ì˜ì–´ ì´ë‹ˆì…œ ë§¤í•‘
      const initialsMap = {
        // Place
        'lawn': 'L',
        'forest': 'F', 
        'valley': 'V',
        'sea': 'S',
        
        // Mood
        'baroque': 'B',
        'romantic': 'R',
        'impression': 'I', 
        'post': 'P',
        
        // Flow
        'recline': 'R',
        'lounge': 'L',
        'settle': 'S',
        'wander': 'W',
        
        // Extras
        'dialogue': 'D',
        'refresh': 'R',
        'play': 'P',
        'fire': 'F'
      };
      
      // ì¥ì†Œ ì˜ì–´ëª… ë§¤í•‘
      const placeEnglishMap = {
        'lawn': 'Lawn',
        'forest': 'Forest',
        'valley': 'Valley', 
        'sea': 'Sea'
      };
      
      // ë¬´ë“œ ì˜ì–´ëª… ë§¤í•‘
      const moodEnglishMap = {
        'baroque': 'Baroque',
        'romantic': 'Romanticism',
        'impression': 'Impressionism',
        'post': 'Postmodernism'
      };
      
      // íƒœë„ ì˜ì–´ëª… ë§¤í•‘
      const flowEnglishMap = {
        'recline': 'Recline',
        'lounge': 'Lounge',
        'settle': 'Settle',
        'wander': 'Wander'
      };
      
      // í–‰ì‚¬ ì˜ì–´ëª… ë§¤í•‘
      const extrasEnglishMap = {
        'dialogue': 'Dialogue',
        'refresh': 'Refreshment',
        'play': 'Playground',
        'fire': 'Fireworks'
      };
      
      // í˜„ì¬ ë‚ ì§œ/ì‹œê°„ ìƒì„±
      const now = new Date();
      const dateStr = now.toISOString().slice(0, 10).replace(/-/g, '/');
      const timeStr = now.toTimeString().slice(0, 5);
      
      // ì´ë‹ˆì…œ ì¡°í•©
      const initials = [
        initialsMap[selections.place] || 'X',
        initialsMap[selections.mood] || 'X', 
        initialsMap[selections.flow] || 'X',
        initialsMap[selections.extras] || 'X'
      ].join('');
      
      const placeEnglish = placeEnglishMap[selections.place] || 'Unknown';
      
      // Stage ì´ë¦„ ê¸¸ì´ ê³„ì‚° (ëŒ€ëµì ì¸ ê¸¸ì´)
      const stageName = `í¬ë¥´íƒ€í†  ${initials} Stage`;
      const stageNameLength = stageName.length;
      
      // ë‚ ì§œ/ì‹œê°„ ê¸¸ì´ ê³„ì‚°
      const dateTimeBase = `${dateStr} â€” ${timeStr}`;
      const dateTimeLength = dateTimeBase.length;
      
      return {
        stageName: stageName,
        dateTime: `${dateStr}&nbsp;&nbsp;&nbsp;â€”&nbsp;&nbsp;&nbsp;${timeStr}`,
        location: `In ${placeEnglish}.`
      };
    }
    
    // ========================================
    // ğŸ“ í…ìŠ¤íŠ¸ ë°°ì¹˜ ì„¤ì • - ì‰½ê²Œ ìˆ˜ì • ê°€ëŠ¥í•˜ë„ë¡ ì •ë¦¬
    // ========================================
    const TEXT_CONFIG = {
      // í°íŠ¸ ì„¤ì •
      fontFamily: "'Sandoll SuPil', sans-serif", // ì „ì²´ í…ìŠ¤íŠ¸ í°íŠ¸
      
      // ì¤„ê°„ê²© ì„¤ì • (ê° ì¤„ì˜ yê°’ ì°¨ì´ = ì¤„ê°„ê²©)
      lineHeight: 5, // ì¤„ ì‚¬ì´ ê°„ê²© (%)
      
      // ì‹œì‘ ìœ„ì¹˜
      startX: 20, // ì²« ë²ˆì§¸ ì¤„ ì™¼ìª½ ì‹œì‘ ìœ„ì¹˜ (%)
      startY: 50, // ì²« ë²ˆì§¸ ì¤„ top ìœ„ì¹˜ (%)
      
      // ë„ˆë¹„ ì„¤ì •
      maxWidth: 80, // ê° ì¤„ì˜ ìµœëŒ€ ë„ˆë¹„ (%)
      
      // í°íŠ¸ í¬ê¸°
      fontSize: 'clamp(1.2vw, 2.2vmin, 1.8vw)',
      
      // ê° ì¤„ë³„ ìœ„ì¹˜ (ìë™ ê³„ì‚° ë˜ëŠ” ìˆ˜ë™ ì„¤ì • ê°€ëŠ¥)
      // xê°’: ì¤„ ì‹œì‘ ìœ„ì¹˜ (ì‘ì„ìˆ˜ë¡ ì™¼ìª½, ê°’ ì°¨ì´ë¥¼ ì¤„ì´ë©´ ì‹œì‘ ìœ„ì¹˜ê°€ ê°€ê¹Œì›Œì§)
      // yê°’: ì¤„ top ìœ„ì¹˜ (ì‘ì„ìˆ˜ë¡ ìœ„, ê°’ ì°¨ì´ë¥¼ í‚¤ìš°ë©´ ì¤„ê°„ê²©ì´ ë„“ì–´ì§)
      lines: [
        { x: 17, y: 60 },    // 1ë²ˆì§¸ ì¤„: ì¥ì†Œ
        { x: 20, y: 67 },  // 2ë²ˆì§¸ ì¤„: ë¬´ë“œ (ì‹œì‘ ìœ„ì¹˜ ê°€ê¹ê²Œ, ì¤„ê°„ê²© ëŠ˜ë¦¼)
        { x: 17, y: 74 },    // 3ë²ˆì§¸ ì¤„: ìì„¸
        { x: 20, y: 81 },  // 4ë²ˆì§¸ ì¤„: ê²½í—˜
        { x: 25, y: 88 }    // 5ë²ˆì§¸ ì¤„: ì•…ê¸°
      ]
    };
    
    // í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ì„¤ì •
    const TEXT_STYLES = {
      // ì„ íƒì§€ í…ìŠ¤íŠ¸ (ì¥ì†Œ, ë¬´ë“œ, ìì„¸, ê²½í—˜)
      selection: {
        color: '#336E74',        // fill ìƒ‰ìƒ
        strokeColor: '#EBFEB3',  // stroke ìƒ‰ìƒ (ë°”ê¹¥ìª½)
        strokeWidth: '0.3px',      // stroke ë‘ê»˜ (text-shadow spreadì— ì˜í–¥ì„ ì¤Œ)
        fontWeight: '900',       // í°íŠ¸ êµµê¸° (ë” ë‘ê»ê²Œ - ìµœëŒ€ê°’)
        letterSpacing: '0em' // ìê°„ì„ ì¤„ì—¬ì„œ ë” ë‘ê»ê²Œ ë³´ì´ë„ë¡
      },
      // ì•…ê¸° ì„ íƒì§€ í…ìŠ¤íŠ¸
      instrument: {
        color: '#AFDEAE',        // fill ìƒ‰ìƒ
        strokeColor: '#336E74',  // stroke ìƒ‰ìƒ (ë°”ê¹¥ìª½)
        strokeWidth: '0.3px',      // stroke ë‘ê»˜ (text-shadow spreadì— ì˜í–¥ì„ ì¤Œ)
        fontWeight: '900',       // í°íŠ¸ êµµê¸° (ë” ë‘ê»ê²Œ - ìµœëŒ€ê°’)
        letterSpacing: '0em' // ìê°„ì„ ì¤„ì—¬ì„œ ë” ë‘ê»ê²Œ ë³´ì´ë„ë¡
      },
      // ì„œìˆ  ë©˜íŠ¸ (ì—ì„œ, ì„, ì¦ê¹ë‹ˆë‹¤, ì´ì–´ê°‘ë‹ˆë‹¤, í•¨ê»˜í•©ë‹ˆë‹¤ ë“±)
      description: {
        color: '#2d5a5f',       // fill ìƒ‰ìƒ
        strokeColor: 'transparent', // stroke ì—†ìŒ
        strokeWidth: '0px',      // stroke ì—†ìŒ
        fontWeight: '900'        // í°íŠ¸ êµµê¸° (bold)
      }
    };
    
    // ========================================
    // ğŸ“ í‹°ì¼“ ì •ë³´ ê° ì¤„ë³„ ê°œë³„ ìœ„ì¹˜ ì„¤ì • (í‹°ì¼“ ê¸°ì¤€ %)
    // ========================================
    const TICKET_INFO_LINES = [
      { x: 70, y: 8, fontSize: 'clamp(0.85vw, 1.5vmin, 1.3vw)' }, // 1ë²ˆì§¸ ì¤„: Stage ì´ë¦„ (ìš°ìƒë‹¨)
      { x: 70, y: 12, fontSize: 'clamp(0.85vw, 1.5vmin, 1.3vw)' }  // 2ë²ˆì§¸ ì¤„: ë‚ ì§œ/ì‹œê°„ (ìš°ìƒë‹¨, ì¤„ê°„ê²© 4%)
      // 3ë²ˆì§¸ ì¤„: ì¥ì†Œ ì‚­ì œë¨
    ];
    
    // ========================================
    // ğŸ“ ì„ íƒì§€ ê²°ê³¼ ì˜ì–´ í…ìŠ¤íŠ¸ ìœ„ì¹˜ ì„¤ì • (í‹°ì¼“ ê¸°ì¤€ %, ìš°ì¸¡ í•˜ë‹¨)
    // ========================================
    const SELECTION_EN_LINES = [
      { y: 85, fontSize: 'clamp(0.85vw, 1.5vmin, 1.3vw)' }, // 1ë²ˆì§¸ ì¤„: In ì¥ì†Œ
      { y: 88.2, fontSize: 'clamp(0.85vw, 1.5vmin, 1.3vw)' }, // 2ë²ˆì§¸ ì¤„: Through ë¬´ë“œ (ì¤„ê°„ê²© 3.2%)
      { y: 91.4, fontSize: 'clamp(0.85vw, 1.5vmin, 1.3vw)' }, // 3ë²ˆì§¸ ì¤„: While íƒœë„ (ì¤„ê°„ê²© 3.2%)
      { y: 94.6, fontSize: 'clamp(0.85vw, 1.5vmin, 1.3vw)' }  // 4ë²ˆì§¸ ì¤„: With í–‰ì‚¬ (ì¤„ê°„ê²© 3.2%)
    ];
    
    // í‹°ì¼“ ì •ë³´ ìƒì„±
    const ticketInfo = generateTicketInfo();
    
    // ì„ íƒì§€ ê²°ê³¼ ì˜ì–´ í…ìŠ¤íŠ¸ ìƒì„±
    function generateSelectionEnglish() {
      const placeEnglishMap = {
        'lawn': 'Lawn',
        'forest': 'Forest',
        'valley': 'Valley', 
        'sea': 'Sea'
      };
      
      const moodEnglishMap = {
        'baroque': 'Baroque',
        'romantic': 'Romanticism',
        'impression': 'Impressionism',
        'post': 'Postmodernism'
      };
      
      const flowEnglishMap = {
        'recline': 'Recline',
        'lounge': 'Lounge',
        'settle': 'Settle',
        'wander': 'Wander'
      };
      
      const extrasEnglishMap = {
        'dialogue': 'Dialogue',
        'refresh': 'Refreshment',
        'play': 'Playground',
        'fire': 'Fireworks'
      };
      
      return {
        place: `In ${placeEnglishMap[selections.place] || 'Unknown'}.`,
        mood: `Through ${moodEnglishMap[selections.mood] || 'Unknown'}.`,
        flow: `While ${flowEnglishMap[selections.flow] || 'Unknown'}.`,
        extras: `With ${extrasEnglishMap[selections.extras] || 'Unknown'}.`
      };
    }
    
    const selectionEnglish = generateSelectionEnglish();
    
    // ========================================
    // ğŸ“ ì•…ê¸° ì˜ì–´ëª… ìœ„ì¹˜ ì„¤ì • (í‹°ì¼“ ê¸°ì¤€ %, ì¢Œì¸¡ í•˜ë‹¨)
    // ì•…ê¸°ê°€ í•˜ë‚˜ì¼ ë•ŒëŠ” ì•„ë˜ì—, ì¶”ê°€ë  ë•Œë§ˆë‹¤ ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” í˜•ì‹
    // ========================================
    const INSTRUMENT_EN_BASE_Y = 94.6; // ê°€ì¥ ì•„ë˜ ìœ„ì¹˜
    const INSTRUMENT_EN_LINE_SPACING = 3.2; // ì¤„ê°„ê²© 3.2%
    
    // ì•…ê¸° ì˜ì–´ëª… ë§¤í•‘ ë° í…ìŠ¤íŠ¸ ìƒì„±
    function generateInstrumentEnglish() {
      const instrumentEnglishMap = {
        'ë°”ì´ì˜¬ë¦°': 'Violin',
        'ë¹„ì˜¬ë¼': 'Viola',
        'ì²¼ë¡œ': 'Cello',
        'íŠ¸ëŸ¼ë³¸': 'Trombone',
        'íŠ¸ëŸ¼í«': 'Trumpet',
        'í˜¸ë¥¸': 'Horn',
        'í”Œë£»': 'Flute',
        'í´ë¼ë¦¬ë„·': 'Clarinet',
        'ì½˜íŠ¸ë¼ë² ì´ìŠ¤': 'Double Bass'
      };
      
      const instruments = selections.instruments || [];
      const instrumentTexts = instruments.slice(0, 3).map(instrument => {
        return instrumentEnglishMap[instrument] || instrument;
      });
      
      return instrumentTexts;
    }
    
    const instrumentEnglishList = generateInstrumentEnglish();
    
    // ì¡°ì‚¬ ë§¤í•‘ìœ¼ë¡œ ì²˜ë¦¬
    const placeEse = 'ì—ì„œ';  // ëª¨ë“  ì¥ì†ŒëŠ” 'ì—ì„œ' ì‚¬ìš©
    
    // ë¬´ë“œ ì¡°ì‚¬ ë§¤í•‘
    const moodEulMap = {
      'ì •êµí•œ ì„ ìœ¨': 'ì„',
      'ê°•ë ¬í•œ ê°ì •': 'ì„', 
      'ëª½í™˜ì  ìŒìƒ‰': 'ì„',
      'ììœ ë¡œìš´ í˜•ì‹': 'ì„'
    };
    const moodEul = moodEulMap[mood] || 'ì„';
    
    // ìì„¸ ì¡°ì‚¬ ë§¤í•‘ (íŠ¹ë³„ ì²˜ë¦¬)
    const flowMap = {
      'í¸ì•ˆíˆ ëˆ„ì›Œ': '',
      'ììœ ë¡­ê²Œ ì•‰ì•„': '',
      'ì¢Œì„ì—ì„œ ëª°ì…': 'í•´ ',
      'ê°€ë³ê²Œ ëŒì•„ë‹¤ë‹ˆë©°': ''
    };
    const flowSuffix = flowMap[flow] || '';
    
    // ê²½í—˜ ì¡°ì‚¬ ë§¤í•‘
    const extrasRoMap = {
      'ì—°ì£¼ìì™€ ëŒ€í™”': 'ë¡œ',
      'ë‹¤ê³¼ ì‹œê°„': 'ìœ¼ë¡œ',
      'ìŒì•… í”Œë ˆì´ì¡´': 'ìœ¼ë¡œ',
      'ë¶ˆë¹› ë§ˆë‹¹': 'ìœ¼ë¡œ'
    };
    const extrasRo = extrasRoMap[extras] || 'ìœ¼ë¡œ';
    
    // í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ í—¬í¼ í•¨ìˆ˜ - ë°”ê¹¥ìª½ ìŠ¤íŠ¸ë¡œí¬ ìƒì„±
    const getTextStrokeStyle = (strokeColor, strokeWidth) => {
      // text-shadowë¥¼ ì‚¬ìš©í•˜ì—¬ í…ìŠ¤íŠ¸ ë°”ê¹¥ìª½ìœ¼ë¡œ ìŠ¤íŠ¸ë¡œí¬ íš¨ê³¼ êµ¬í˜„
      // ë” ë§ì€ ë°©í–¥ê³¼ ë” í° spreadë¡œ ë°”ê¹¥ìª½ ìŠ¤íŠ¸ë¡œí¬ ìƒì„±
      const w = parseFloat(strokeWidth.replace('px', '')) || 1;
      const spread = Math.max(2, w * 2); // ìŠ¤íŠ¸ë¡œí¬ê°€ ë°”ê¹¥ìœ¼ë¡œ í™•ì¥ë˜ë„ë¡ ì ì ˆí•œ ê°’ ì‚¬ìš© (ì ˆë°˜ ì •ë„ë¡œ ì¤„ì„)
      
      const shadows = [
        // 8ë°©í–¥ ê¸°ë³¸ shadow (ë” ë‘ê»ê²Œ)
        `-${spread}px -${spread}px 0 ${strokeColor}`,
        `${spread}px -${spread}px 0 ${strokeColor}`,
        `-${spread}px ${spread}px 0 ${strokeColor}`,
        `${spread}px ${spread}px 0 ${strokeColor}`,
        `-${spread}px 0 0 ${strokeColor}`,
        `${spread}px 0 0 ${strokeColor}`,
        `0 -${spread}px 0 ${strokeColor}`,
        `0 ${spread}px 0 ${strokeColor}`,
        // ì¤‘ê°„ ê±°ë¦¬ shadow (ë” ë¶€ë“œëŸ¬ìš´ ì™¸ê³½ì„ )
        `-${spread * 0.7}px -${spread * 0.7}px 0 ${strokeColor}`,
        `${spread * 0.7}px -${spread * 0.7}px 0 ${strokeColor}`,
        `-${spread * 0.7}px ${spread * 0.7}px 0 ${strokeColor}`,
        `${spread * 0.7}px ${spread * 0.7}px 0 ${strokeColor}`,
        // ê°€ê¹Œìš´ ê±°ë¦¬ shadow (ë‚´ë¶€ ì±„ì›€)
        `-${spread * 0.5}px -${spread * 0.5}px 0 ${strokeColor}`,
        `${spread * 0.5}px -${spread * 0.5}px 0 ${strokeColor}`,
        `-${spread * 0.5}px ${spread * 0.5}px 0 ${strokeColor}`,
        `${spread * 0.5}px ${spread * 0.5}px 0 ${strokeColor}`,
        `-${spread * 0.5}px 0 0 ${strokeColor}`,
        `${spread * 0.5}px 0 0 ${strokeColor}`,
        `0 -${spread * 0.5}px 0 ${strokeColor}`,
        `0 ${spread * 0.5}px 0 ${strokeColor}`,
      ].join(', ');
      return shadows;
    };
    
    // ê° ì¤„ë³„ í…ìŠ¤íŠ¸ ìƒì„±
    const lines = TEXT_CONFIG.lines;
    const textHTML = `
      <!-- 1ë²ˆì§¸ ì¤„: ì¥ì†Œ ì„ íƒì§€ -->
      <div style="
        position: absolute;
        left: ${lines[0].x}%;
        top: ${lines[0].y}%;
        font-family: ${TEXT_CONFIG.fontFamily};
        font-size: ${TEXT_CONFIG.fontSize};
        color: ${TEXT_STYLES.description.color};
        font-weight: ${TEXT_STYLES.description.fontWeight};
        z-index: 150;
        max-width: ${TEXT_CONFIG.maxWidth}%;
        line-height: 1.4;
      ">
        '<span style="
          color: ${TEXT_STYLES.selection.color};
          font-weight: ${TEXT_STYLES.selection.fontWeight};
          letter-spacing: ${TEXT_STYLES.selection.letterSpacing};
          text-shadow: ${getTextStrokeStyle(TEXT_STYLES.selection.strokeColor, TEXT_STYLES.selection.strokeWidth)};
          display: inline-block;
        ">${place}</span>' ${placeEse},
      </div>
      
      <!-- 2ë²ˆì§¸ ì¤„: ë¬´ë“œ ì„ íƒì§€ -->
      <div style="
        position: absolute;
        left: ${lines[1].x}%;
        top: ${lines[1].y}%;
        font-family: ${TEXT_CONFIG.fontFamily};
        font-size: ${TEXT_CONFIG.fontSize};
        color: ${TEXT_STYLES.description.color};
        font-weight: ${TEXT_STYLES.description.fontWeight};
        z-index: 150;
        max-width: ${TEXT_CONFIG.maxWidth}%;
        line-height: 1.4;
      ">
        '<span style="
          color: ${TEXT_STYLES.selection.color};
          font-weight: ${TEXT_STYLES.selection.fontWeight};
          letter-spacing: ${TEXT_STYLES.selection.letterSpacing};
          text-shadow: ${getTextStrokeStyle(TEXT_STYLES.selection.strokeColor, TEXT_STYLES.selection.strokeWidth)};
          display: inline-block;
        ">${mood}</span>' ${moodEul},
      </div>
      
      <!-- 3ë²ˆì§¸ ì¤„: ìì„¸ ì„ íƒì§€ -->
      <div style="
        position: absolute;
        left: ${lines[2].x}%;
        top: ${lines[2].y}%;
        font-family: ${TEXT_CONFIG.fontFamily};
        font-size: ${TEXT_CONFIG.fontSize};
        color: ${TEXT_STYLES.description.color};
        font-weight: ${TEXT_STYLES.description.fontWeight};
        z-index: 150;
        max-width: ${TEXT_CONFIG.maxWidth}%;
        line-height: 1.4;
      ">
        '<span style="
          color: ${TEXT_STYLES.selection.color};
          font-weight: ${TEXT_STYLES.selection.fontWeight};
          letter-spacing: ${TEXT_STYLES.selection.letterSpacing};
          text-shadow: ${getTextStrokeStyle(TEXT_STYLES.selection.strokeColor, TEXT_STYLES.selection.strokeWidth)};
          display: inline-block;
        ">${flow}</span>' ${flowSuffix}ì¦ê¹ë‹ˆë‹¤.
      </div>
      
      <div style="
        position: absolute;
        left: ${lines[3].x}%;
        top: ${lines[3].y}%;
        font-family: ${TEXT_CONFIG.fontFamily};
        font-size: ${TEXT_CONFIG.fontSize};
        color: ${TEXT_STYLES.description.color};
        font-weight: ${TEXT_STYLES.description.fontWeight};
        z-index: 150;
        max-width: ${TEXT_CONFIG.maxWidth}%;
        line-height: 1.4;
      ">
        '<span style="
          color: ${TEXT_STYLES.selection.color};
          font-weight: ${TEXT_STYLES.selection.fontWeight};
          letter-spacing: ${TEXT_STYLES.selection.letterSpacing};
          text-shadow: ${getTextStrokeStyle(TEXT_STYLES.selection.strokeColor, TEXT_STYLES.selection.strokeWidth)};
          display: inline-block;
        ">${extras}</span>' ${extrasRo} ì´ì–´ê°‘ë‹ˆë‹¤.
      </div>
      
      <!-- 5ë²ˆì§¸ ì¤„: ì•…ê¸° ì„ íƒì§€ -->
      <div style="
        position: absolute;
        left: ${lines[4].x}%;
        top: ${lines[4].y}%;
        font-family: ${TEXT_CONFIG.fontFamily};
        font-size: ${TEXT_CONFIG.fontSize};
        color: ${TEXT_STYLES.description.color};
        font-weight: ${TEXT_STYLES.description.fontWeight};
        z-index: 150;
        max-width: ${TEXT_CONFIG.maxWidth}%;
        line-height: 1.4;
      ">
        <span style="
          color: ${TEXT_STYLES.instrument.color};
          font-weight: ${TEXT_STYLES.instrument.fontWeight};
          letter-spacing: ${TEXT_STYLES.instrument.letterSpacing};
          text-shadow: ${getTextStrokeStyle(TEXT_STYLES.instrument.strokeColor, TEXT_STYLES.instrument.strokeWidth)};
          display: inline-block;
        ">${instrumentText}</span> ${particle} í•¨ê»˜í•©ë‹ˆë‹¤.
      </div>
      
      <!-- í‹°ì¼“ ì •ë³´ - ê° ì¤„ë³„ ê°œë³„ ì„¤ì • (ìš°ìƒë‹¨) -->
      <div style="
        position: absolute;
        right: 15%;
        top: ${TICKET_INFO_LINES[0].y}%;
        text-align: right;
        font-family: var(--font-sub);
        font-size: ${TICKET_INFO_LINES[0].fontSize};
        color: #336E74;
        z-index: 160;
      ">
        ${ticketInfo.stageName}
      </div>
      
      <div style="
        position: absolute;
        right: 15%;
        top: ${TICKET_INFO_LINES[1].y}%;
        text-align: right;
        font-family: var(--font-sub);
        font-size: ${TICKET_INFO_LINES[1].fontSize};
        color: #336E74;
        z-index: 160;
      ">
        ${ticketInfo.dateTime}
      </div>
      
      <!-- ì„ íƒì§€ ê²°ê³¼ ì˜ì–´ í…ìŠ¤íŠ¸ (ìš°ì¸¡ í•˜ë‹¨) -->
      <div style="
        position: absolute;
        right: 15%;
        top: ${SELECTION_EN_LINES[0].y}%;
        text-align: right;
        font-family: var(--font-sub);
        font-size: ${SELECTION_EN_LINES[0].fontSize};
        color: #336E74;
        z-index: 160;
      ">
        ${selectionEnglish.place}
      </div>
      
      <div style="
        position: absolute;
        right: 15%;
        top: ${SELECTION_EN_LINES[1].y}%;
        text-align: right;
        font-family: var(--font-sub);
        font-size: ${SELECTION_EN_LINES[1].fontSize};
        color: #336E74;
        z-index: 160;
      ">
        ${selectionEnglish.mood}
      </div>
      
      <div style="
        position: absolute;
        right: 15%;
        top: ${SELECTION_EN_LINES[2].y}%;
        text-align: right;
        font-family: var(--font-sub);
        font-size: ${SELECTION_EN_LINES[2].fontSize};
        color: #336E74;
        z-index: 160;
      ">
        ${selectionEnglish.flow}
      </div>
      
      <div style="
        position: absolute;
        right: 15%;
        top: ${SELECTION_EN_LINES[3].y}%;
        text-align: right;
        font-family: var(--font-sub);
        font-size: ${SELECTION_EN_LINES[3].fontSize};
        color: #336E74;
        z-index: 160;
      ">
        ${selectionEnglish.extras}
      </div>
      
      <!-- ì•…ê¸° ì˜ì–´ëª… í…ìŠ¤íŠ¸ (ì¢Œì¸¡ í•˜ë‹¨, ì•…ê¸°ë³„ ì¤„ë„˜ê¹€) -->
      ${instrumentEnglishList.length > 0 ? instrumentEnglishList.map((instrument, index) => {
        // ì•…ê¸°ê°€ í•˜ë‚˜ì¼ ë•ŒëŠ” ì•„ë˜ì—, ì¶”ê°€ë  ë•Œë§ˆë‹¤ ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” í˜•ì‹
        // ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬: ë§ˆì§€ë§‰ ì•…ê¸°ê°€ ê°€ì¥ ì•„ë˜ì—
        const reversedIndex = instrumentEnglishList.length - 1 - index;
        const yPos = INSTRUMENT_EN_BASE_Y - (reversedIndex * INSTRUMENT_EN_LINE_SPACING);
        
        return '<div style="position: absolute; left: 60%; top: ' + yPos + '%; text-align: left; font-family: var(--font-sub); font-size: clamp(0.85vw, 1.5vmin, 1.3vw); color: #336E74; z-index: 160;">' + instrument + '</div>';
      }).join('') : ''}
    `;
    
    return textHTML;
  }
  
  // ğŸ¯ ì‚¬ìš©ì ì„ íƒ ì´ë¯¸ì§€ë¥¼ ì‚¬ë¶„ë©´ ë°°ì¹˜ë¡œ ë°°ì¹˜í•˜ëŠ” í•¨ìˆ˜ (right_circle í¬ê¸°ì— ë¹„ë¡€)
  function autoArrangeImagesWithPixelAccuracy(draggableImages, ticketContent) {
    console.log('ğŸ”„ ì‚¬ë¶„ë©´ ë°°ì¹˜ ì‹œì‘ (right_circle í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ ë°°ì¹˜)');
    
    const ticketContentRect = ticketContent.getBoundingClientRect();
    const rightCircleEl = document.getElementById('rightCircle');
    
    if (!rightCircleEl) {
      console.error('âŒ rightCircle ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
      return;
    }
    
    // right_circleì˜ ì‹¤ì œ í¬ê¸°ì™€ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
    const rightCircleRect = rightCircleEl.getBoundingClientRect();
    const circleWidth = rightCircleRect.width;
    const circleHeight = rightCircleRect.height;
    
    // right_circleì˜ ìœ„ì¹˜ (ticketContent ê¸°ì¤€ - ì •í™•í•œ ê³„ì‚°)
    const circleLeft = rightCircleRect.left - ticketContentRect.left;
    const circleTop = rightCircleRect.top - ticketContentRect.top;
    const circleRight = circleLeft + circleWidth;
    const circleBottom = circleTop + circleHeight;
    
    // right_circle ì¤‘ì‹¬
    const circleCenterX = circleLeft + circleWidth / 2;
    const circleCenterY = circleTop + circleHeight / 2;
    
    console.log(`ğŸ“ right_circle ì •ë³´:`);
    console.log(`  - ì ˆëŒ€ ìœ„ì¹˜ (í™”ë©´ ê¸°ì¤€): left=${rightCircleRect.left.toFixed(1)}px, top=${rightCircleRect.top.toFixed(1)}px`);
    console.log(`  - ticketContent ê¸°ì¤€: left=${circleLeft.toFixed(1)}px, top=${circleTop.toFixed(1)}px`);
    console.log(`  - í¬ê¸°: ${circleWidth.toFixed(1)}px Ã— ${circleHeight.toFixed(1)}px`);
    console.log(`  - ê²½ê³„: left=${circleLeft.toFixed(1)}, right=${circleRight.toFixed(1)}, top=${circleTop.toFixed(1)}, bottom=${circleBottom.toFixed(1)}`);
    console.log(`  - ì¤‘ì‹¬: (${circleCenterX.toFixed(1)}, ${circleCenterY.toFixed(1)})`);
    
    // right_circle ë‚´ë¶€ ì—¬ë°± (ê·¸ë˜í”½ì´ ê²½ê³„ì— ë‹¿ì§€ ì•Šë„ë¡ - ë” í¬ê²Œ)
    const padding = Math.min(circleWidth, circleHeight) * 0.20; // 20% ì—¬ë°±ìœ¼ë¡œ ì¦ê°€
    
    // ì‹¤ì œ ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ì—­ ê³„ì‚°
    const usableLeft = circleLeft + padding;
    const usableRight = circleRight - padding;
    const usableTop = circleTop + padding;
    const usableBottom = circleBottom - padding;
    const usableWidth = usableRight - usableLeft;
    const usableHeight = usableBottom - usableTop;
    
    console.log(`ğŸ“ ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ì—­: ${usableWidth.toFixed(1)}px Ã— ${usableHeight.toFixed(1)}px`);
    
    // ì•…ê¸° ê·¸ë˜í”½ê³¼ ì¼ë°˜ ê·¸ë˜í”½ ë¶„ë¦¬
    const instrumentImages = [];
    const regularImages = [];
    
    draggableImages.forEach((img) => {
      const imgSrc = img.src || '';
      const imgAlt = img.alt || '';
      // ì•…ê¸° ê·¸ë˜í”½ì€ instruments í´ë”ì— ìˆê±°ë‚˜ í•œê¸€ ì•…ê¸°ëª…ì´ altì— ìˆëŠ” ê²½ìš°
      if (imgSrc.includes('/instruments/') || /(ë°”ì´ì˜¬ë¦°|ë¹„ì˜¬ë¼|ì²¼ë¡œ|íŠ¸ëŸ¼ë³¸|íŠ¸ëŸ¼í«|í˜¸ë¥¸|í”Œë£»|í´ë¼ë¦¬ë„·|ì½˜íŠ¸ë¼ë² ì´ìŠ¤)/.test(imgAlt)) {
        instrumentImages.push(img);
      } else {
        regularImages.push(img);
      }
    });
    
    console.log(`ğŸ“¦ ì•…ê¸° ê·¸ë˜í”½: ${instrumentImages.length}ê°œ, ì¼ë°˜ ê·¸ë˜í”½: ${regularImages.length}ê°œ`);
    
    // ì¼ë°˜ ê·¸ë˜í”½ì€ ì‚¬ë¶„ë©´ ë°°ì¹˜
    const usableCenterX = usableLeft + usableWidth / 2;
    const usableCenterY = usableTop + usableHeight / 2;
    
    const quadrantPositions = [
      { // NE (ìš°ìƒë‹¨) - ì¤‘ì‹¬ ê¸°ì¤€ ìš°ìƒë‹¨ (ìœ„ë¡œ ì˜¬ë¦¼)
        x: usableCenterX + usableWidth * 0.68,  // ì¤‘ì‹¬ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ 68%
        y: usableCenterY - usableHeight * 0.55  // ì¤‘ì‹¬ì—ì„œ ìœ„ë¡œ 55% (65% â†’ 55%, ë” ìœ„ë¡œ ì˜¬ë¦¼)
      },
      { // NW (ì¢Œìƒë‹¨) - ì¤‘ì‹¬ ê¸°ì¤€ ì¢Œìƒë‹¨ (ìœ„ë¡œ ì˜¬ë¦¼)
        x: usableCenterX - usableWidth * 0.68,  // ì¤‘ì‹¬ì—ì„œ ì™¼ìª½ìœ¼ë¡œ 68%
        y: usableCenterY - usableHeight * 0.55  // ì¤‘ì‹¬ì—ì„œ ìœ„ë¡œ 55% (65% â†’ 55%, ë” ìœ„ë¡œ ì˜¬ë¦¼)
      },
      { // SE (ìš°í•˜ë‹¨) - ì¤‘ì‹¬ ê¸°ì¤€ ìš°í•˜ë‹¨ (ìœ„ë¡œ ì˜¬ë¦¼, í•˜ì§€ë§Œ ì•…ê¸°ë³´ë‹¤ëŠ” ìœ„)
        x: usableCenterX + usableWidth * 0.68,  // ì¤‘ì‹¬ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ 68%
        y: usableCenterY + usableHeight * 0.30  // ì¤‘ì‹¬ì—ì„œ ì•„ë˜ë¡œ 30% (40% â†’ 30%, ë” ìœ„ë¡œ ì˜¬ë¦¼)
      },
      { // SW (ì¢Œí•˜ë‹¨) - ì¤‘ì‹¬ ê¸°ì¤€ ì¢Œí•˜ë‹¨ (ìœ„ë¡œ ì˜¬ë¦¼, í•˜ì§€ë§Œ ì•…ê¸°ë³´ë‹¤ëŠ” ìœ„)
        x: usableCenterX - usableWidth * 0.68,  // ì¤‘ì‹¬ì—ì„œ ì™¼ìª½ìœ¼ë¡œ 68%
        y: usableCenterY + usableHeight * 0.30  // ì¤‘ì‹¬ì—ì„œ ì•„ë˜ë¡œ 30% (40% â†’ 30%, ë” ìœ„ë¡œ ì˜¬ë¦¼)
      }
    ];
    
    // ì•…ê¸° ê·¸ë˜í”½ì€ ì¼ë ¬ ë°°ì¹˜ (ì¼ë°˜ ê·¸ë˜í”½ í•˜ë‹¨ë³´ë‹¤ ì•„ë˜) - ë” ë‚´ë ¤ì„œ ì¼ë°˜ ê·¸ë˜í”½ í•˜ë‹¨ê³¼ ëª…í™•íˆ êµ¬ë¶„
    const baseY = circleCenterY + circleHeight * 0.25; // ì¤‘ì‹¬ì—ì„œ ì•„ë˜ë¡œ 25% ìœ„ì¹˜ (ì¼ë°˜ ê·¸ë˜í”½ í•˜ë‹¨ 30%ë³´ë‹¤ ì•„ë˜)
    const numInstrumentImages = instrumentImages.length;
    const horizontalSpacing = numInstrumentImages > 0 ? usableWidth / (numInstrumentImages + 1) : 0;
    
    console.log('ğŸ“ ì‚¬ë¶„ë©´ ìœ„ì¹˜ (í”½ì…€ ë‹¨ìœ„, ì¤‘ì‹¬ ê¸°ì¤€):');
    console.log(`  ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ì—­ ì¤‘ì‹¬: (${usableCenterX.toFixed(1)}, ${usableCenterY.toFixed(1)})`);
    quadrantPositions.forEach((pos, idx) => {
      const names = ['NE', 'NW', 'SE', 'SW'];
      const isWithinX = pos.x >= usableLeft && pos.x <= usableRight;
      const isWithinY = pos.y >= usableTop && pos.y <= usableBottom;
      console.log(`  ${names[idx]}: x=${pos.x.toFixed(1)}px, y=${pos.y.toFixed(1)}px`);
      console.log(`    â†’ right_circle ë‚´ë¶€ í™•ì¸: ${isWithinX && isWithinY ? 'âœ…' : 'âŒ'} (x: ${isWithinX}, y: ${isWithinY})`);
    });
    
    if (numInstrumentImages > 0) {
      console.log('ğŸ“ ì•…ê¸° ì¼ë ¬ ë°°ì¹˜ ìœ„ì¹˜ (ì¼ë°˜ ê·¸ë˜í”½ í•˜ë‹¨ë³´ë‹¤ ì•„ë˜):');
      console.log(`  ê¸°ë³¸ Y ìœ„ì¹˜: ${baseY.toFixed(1)}px (ì›í˜• ì¤‘ì‹¬ì—ì„œ ì•„ë˜ë¡œ ${(baseY - circleCenterY).toFixed(1)}px)`);
      console.log(`  ê°€ë¡œ ê°„ê²©: ${horizontalSpacing.toFixed(1)}px`);
    }
    
    // right_circle í¬ê¸°ì— ë¹„ë¡€í•œ ìµœëŒ€ ì´ë¯¸ì§€ í¬ê¸° ê³„ì‚° (ì¨í´ í¬ê¸°ì— ë¹„ë¡€)
    // ì¨í´ í¬ê¸°ì˜ ì¼ì • ë¹„ìœ¨ë¡œ ì œí•œ (ê·¸ë˜í”½ í¬ê¸° 50% ë³´ì¥ì„ ìœ„í•´ ì¶©ë¶„í•œ ì—¬ìœ )
    const circleReferenceSize = Math.min(circleWidth, circleHeight);
    const maxImageSize = circleReferenceSize * 0.65; // ì¨í´ í¬ê¸°ì˜ 65%ë¡œ ì œí•œ (í¬ê¸° ë³´ì¥)
    
    console.log(`ğŸ“ ìµœëŒ€ ì´ë¯¸ì§€ í¬ê¸°: ${maxImageSize.toFixed(1)}px`);
    
    // ì¼ë°˜ ê·¸ë˜í”½ ì‚¬ë¶„ë©´ ë°°ì¹˜
    regularImages.forEach((img, index) => {
      console.log(`ğŸ“¦ ${index + 1}ë²ˆì§¸ ì´ë¯¸ì§€ ì²˜ë¦¬:`, img.src.split('/').pop());
      
      // ì´ë¯¸ì§€ê°€ ì™„ì „íˆ ë¡œë“œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„ í¬ê¸° í™•ì¸
      const updateImagePosition = () => {
        // ë“œë˜ê·¸ ì¤‘ì¼ ë•ŒëŠ” ìœ„ì¹˜ ì¬ì„¤ì •í•˜ì§€ ì•ŠìŒ
        if (img.dataset.isDragging === 'true') {
          console.log('â­ï¸ ë“œë˜ê·¸ ì¤‘ - ìœ„ì¹˜ ì¬ì„¤ì • ê±´ë„ˆëœ€');
          return;
        }
        
        // ì´ˆê¸° ìœ„ì¹˜ê°€ ì´ë¯¸ ì„¤ì •ë˜ì—ˆê³ , ì‚¬ìš©ìê°€ ì§ì ‘ ë“œë˜ê·¸í•œ ê²½ìš° ìœ„ì¹˜ ì¬ì„¤ì •í•˜ì§€ ì•ŠìŒ
        if (img.dataset.initialPositionSet === 'true' && img.dataset.userMoved === 'true') {
          console.log('â­ï¸ ì‚¬ìš©ìê°€ ì§ì ‘ ì´ë™ì‹œí‚¨ ì´ë¯¸ì§€ - ìœ„ì¹˜ ì¬ì„¤ì • ê±´ë„ˆëœ€');
          return;
        }
        // ì‚¬ë¶„ë©´ ìœ„ì¹˜ ê²°ì • (ìµœëŒ€ 4ê°œê¹Œì§€, ê·¸ ì´í›„ëŠ” ìˆœí™˜)
        const quadrantIndex = index % 4;
        const pos = quadrantPositions[quadrantIndex];
        
        // ì›ë³¸ ì´ë¯¸ì§€ í¬ê¸°
        const originalWidth = img.naturalWidth;
        const originalHeight = img.naturalHeight;
        const aspectRatio = originalHeight / originalWidth;
        
        // right_circle í¬ê¸°ì— ë¹„ë¡€í•œ í¬ê¸° ê³„ì‚° (ì¨í´ í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ ìë™ ì¡°ì •)
        // right_circleì˜ ì‘ì€ ë³€(ë„ˆë¹„ ë˜ëŠ” ë†’ì´)ì„ ê¸°ì¤€ìœ¼ë¡œ ë¹„ìœ¨ ê³„ì‚°
        const circleReferenceSize = Math.min(circleWidth, circleHeight);
        
        // baseScaleì„ ì¨í´ í¬ê¸°ì— ë¹„ë¡€í•˜ë„ë¡ ê³„ì‚°
        const baseScale = img.dataset.scale ? parseFloat(img.dataset.scale) : 0.5;
        // ì¨í´ í¬ê¸°ì˜ ì¼ì • ë¹„ìœ¨ì„ ì°¨ì§€í•˜ë„ë¡ ì„¤ì • (ì¼ë°˜ ê·¸ë˜í”½ í¬ê¸° ì¡°ì •, ê°„ê²© ìœ ì§€)
        const targetSizeRatio = circleReferenceSize * 0.45; // ì¨í´ í¬ê¸°ì˜ 45%ë¥¼ ì°¨ì§€ (ê°„ê²© í™•ë³´)
        const targetSize = targetSizeRatio;
        
        // ì›ë³¸ ì´ë¯¸ì§€ ë¹„ìœ¨ ìœ ì§€í•˜ë©´ì„œ targetSizeì— ë§ì¶”ê¸°
        let targetWidth, targetHeight;
        if (originalWidth > originalHeight) {
          // ê°€ë¡œê°€ ë” ê¸´ ê²½ìš°
          targetWidth = targetSize;
          targetHeight = targetSize * aspectRatio;
        } else {
          // ì„¸ë¡œê°€ ë” ê¸´ ê²½ìš°
          targetHeight = targetSize;
          targetWidth = targetSize / aspectRatio;
        }
        
        // ìµœëŒ€ í¬ê¸° ì œí•œ (ì ˆëŒ€ì ì¸ ì œí•œ)
        if (targetWidth > maxImageSize || targetHeight > maxImageSize) {
          const scaleByWidth = maxImageSize / targetWidth;
          const scaleByHeight = maxImageSize / targetHeight;
          const finalScale = Math.min(scaleByWidth, scaleByHeight);
          targetWidth *= finalScale;
          targetHeight *= finalScale;
        }
        
        // ë°˜ë“œì‹œ ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ì—­ ë‚´ì— ë“¤ì–´ê°€ë„ë¡ ì¶”ê°€ ê²€ì¦
        const halfWidth = targetWidth / 2;
        const halfHeight = targetHeight / 2;
        
        // ìµœì¢… ê²€ì¦: ì¨í´ í¬ê¸° ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°í•œ í¬ê¸°ë¥¼ ìš°ì„ í•˜ë˜, ì¨í´ ê²½ê³„ë¥¼ ë„˜ì§€ ì•Šë„ë¡ë§Œ ì²´í¬
        // ì¨í´ì˜ ì‹¤ì œ í¬ê¸°(ì›í˜• ê²½ê³„ ê³ ë ¤)ë¡œ ìµœëŒ€ í¬ê¸° í™•ì¸ (ê·¸ë˜í”½ í¬ê¸° 50% ë³´ì¥ + ê°„ê²© í™•ë³´)
        // 50% í¬ê¸°ì˜ ëŒ€ê°ì„  = 50% * sqrt(2) â‰ˆ 0.707, ë”°ë¼ì„œ ì¶©ë¶„í•œ ì—¬ìœ  í•„ìš”
        const maxSizeByCircle = circleReferenceSize * 0.85; // ì¨í´ í¬ê¸°ì˜ 85%ê¹Œì§€ë§Œ í—ˆìš© (í¬ê¸° ì œí•œ ì™„í™”)
        const maxDiagonal = Math.sqrt(targetWidth ** 2 + targetHeight ** 2);
        if (maxDiagonal > maxSizeByCircle) {
          const scale = maxSizeByCircle / maxDiagonal;
          targetWidth *= scale;
          targetHeight *= scale;
        }
        
        // ê²½ê³„ ì²´í¬: ì›í˜• ê²½ê³„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì²´í¬ (ì‚¬ê°í˜• ê²½ê³„ ì œí•œ ì™„í™”)
        // ì‚¬ë¶„ë©´ ìœ„ì¹˜ë¥¼ ìµœìš°ì„ ìœ¼ë¡œ ìœ ì§€í•˜ê³ , ì›í˜• ê²½ê³„ë§Œ ì²´í¬
        let finalX = pos.x;
        let finalY = pos.y;
        
        // ì›í˜• ê²½ê³„ ì²´í¬: ì´ë¯¸ì§€ì˜ ê°€ì¥ ë°”ê¹¥ìª½ ì ì´ ì›ì„ ë„˜ëŠ”ì§€ ì²´í¬ (ê°„ê²© í™•ë³´ë¥¼ ìœ„í•´ ì™„í™”)
        const distanceFromCenter = Math.sqrt((finalX - circleCenterX) ** 2 + (finalY - circleCenterY) ** 2);
        const circleRadius = Math.min(circleWidth, circleHeight) / 2; // ì¨í´ì˜ ì‹¤ì œ ë°˜ì§€ë¦„
        const imageHalfDiagonal = Math.sqrt(halfWidth ** 2 + halfHeight ** 2); // ì´ë¯¸ì§€ ì¤‘ì‹¬ì—ì„œ ê°€ì¥ ë¨¼ ì ê¹Œì§€ì˜ ê±°ë¦¬
        
        // ê°„ê²©ì„ ìµœëŒ€í•œ ìœ ì§€í•˜ê¸° ìœ„í•´ ê²½ê³„ ì²´í¬ ëŒ€í­ ì™„í™”
        // quadrantPositionsì—ì„œ ì„¤ì •í•œ ê°„ê²©ì„ ì ˆëŒ€ì ìœ¼ë¡œ ìš°ì„ 
        const safetyMargin = 0; // ì•ˆì „ ë§ˆì§„ ì œê±° (ê°„ê²© ìµœëŒ€í™”)
        const maxAllowedDistance = circleRadius - imageHalfDiagonal - safetyMargin;
        
        // desiredDistanceëŠ” quadrantPositionsì—ì„œ ì„¤ì •í•œ ìœ„ì¹˜ì˜ ì¤‘ì‹¬ ê±°ë¦¬
        const desiredDistance = Math.sqrt((pos.x - circleCenterX) ** 2 + (pos.y - circleCenterY) ** 2);
        
        // ì›í˜• ê²½ê³„ë¥¼ ë„˜ëŠ” ê²½ìš°ì—ë§Œ ìµœì†Œí•œìœ¼ë¡œ ì¡°ì • (ê°„ê²© ìµœëŒ€í•œ ìœ ì§€)
        // ê°„ê²©ì„ ìš°ì„ í•˜ë¯€ë¡œ ë” ê´€ëŒ€í•˜ê²Œ ì²´í¬
        if (distanceFromCenter + imageHalfDiagonal > circleRadius - 5) { // 5px ì•ˆì „ ì—¬ë°±
          // ì›í˜• ê²½ê³„ë¥¼ ì•½ê°„ ë„˜ì–´ë„ í—ˆìš©í•˜ë˜, ë„ˆë¬´ ë§ì´ ë„˜ìœ¼ë©´ ì¡°ì •
          const angle = Math.atan2(finalY - circleCenterY, finalX - circleCenterX);
          
          // ì›í•˜ëŠ” ìœ„ì¹˜ë¥¼ ìµœìš°ì„ ìœ¼ë¡œ í•˜ë˜, ì›í˜• ê²½ê³„ë¥¼ í¬ê²Œ ë„˜ì§€ ì•Šë„ë¡ë§Œ ì œí•œ
          const newDistanceFromCenter = Math.min(desiredDistance, maxAllowedDistance); // ì—¬ìœ  ì œê±°
          
          // ì´ë¯¸ì§€ê°€ ë„ˆë¬´ ì»¤ì„œ newDistanceFromCenterê°€ ìŒìˆ˜ê°€ ë˜ëŠ” ê²½ìš° ë°©ì§€
          if (newDistanceFromCenter < 0) {
            finalX = circleCenterX;
            finalY = circleCenterY;
          } else {
            finalX = circleCenterX + Math.cos(angle) * newDistanceFromCenter;
            finalY = circleCenterY + Math.sin(angle) * newDistanceFromCenter;
          }
        }
        
        // ìµœì¢… ê²½ê³„ ê²€ì¦: ì›í˜• ê²½ê³„ë§Œ ì²´í¬ (ì‚¬ê°í˜• ê²½ê³„ ì œê±°ë¡œ ê°„ê²© í™•ë³´)
        // ì›í˜• ê²½ê³„ ì²´í¬ëŠ” ì´ë¯¸ ìœ„ì—ì„œ ìˆ˜í–‰í–ˆìœ¼ë¯€ë¡œ, ì‚¬ê°í˜• ê²½ê³„ ì²´í¬ëŠ” ì œê±°
        // ì´ë ‡ê²Œ í•˜ë©´ quadrantPositionsì—ì„œ ì„¤ì •í•œ 58% ê°„ê²©ì´ ì œëŒ€ë¡œ ì ìš©ë¨
        const finalLeft = finalX - halfWidth;
        const finalRight = finalX + halfWidth;
        const finalTop = finalY - halfHeight;
        const finalBottom = finalY + halfHeight;
        
        // ì›í˜• ê²½ê³„ë§Œ ìµœì¢… í™•ì¸ (ì´ë¯¸ ìœ„ì—ì„œ ì²´í¬í–ˆì§€ë§Œ í•œ ë²ˆ ë” í™•ì¸)
        const finalDistanceFromCenter = Math.sqrt((finalX - circleCenterX) ** 2 + (finalY - circleCenterY) ** 2);
        const finalImageHalfDiagonal = Math.sqrt(halfWidth ** 2 + halfHeight ** 2);
        const isWithinCircle = finalDistanceFromCenter + finalImageHalfDiagonal <= circleRadius;
        
        if (!isWithinCircle) {
          console.warn(`âš ï¸ ì›í˜• ê²½ê³„ ì²´í¬: ì´ë¯¸ì§€ê°€ ì›ì„ ì•½ê°„ ë„˜ìŒ. ì¶”ê°€ ì¡°ì •...`);
          // ì›í˜• ê²½ê³„ ë‚´ë¡œ ìµœì†Œí•œë§Œ ì¡°ì •
          const angle = Math.atan2(finalY - circleCenterY, finalX - circleCenterX);
          const safeDistance = circleRadius - finalImageHalfDiagonal - 3;
          if (safeDistance > 0) {
            finalX = circleCenterX + Math.cos(angle) * safeDistance;
            finalY = circleCenterY + Math.sin(angle) * safeDistance;
          }
        }
        
        // í¼ì„¼íŠ¸ë¡œ ë³€í™˜ (finalX, finalYëŠ” ì´ë¯¸ ticketContent ê¸°ì¤€ ìƒëŒ€ ì¢Œí‘œ)
        // circleLeft, circleTop ê³„ì‚° ì‹œ ì´ë¯¸ ticketContentRect.left/topì„ ë¹¼ì„œ
        // finalX, finalYëŠ” ì´ë¯¸ ìƒëŒ€ ì¢Œí‘œì„
        let leftPercent = (finalX / ticketContentRect.width) * 100;
        let topPercent = (finalY / ticketContentRect.height) * 100;
        
        console.log(`  ğŸ“ ìµœì¢… ìœ„ì¹˜ ê³„ì‚°: finalX=${finalX.toFixed(1)}px, finalY=${finalY.toFixed(1)}px â†’ left=${leftPercent.toFixed(2)}%, top=${topPercent.toFixed(2)}%`);
        
        img.style.left = leftPercent + '%';
        img.style.top = topPercent + '%';
        img.style.width = targetWidth + 'px';
        img.style.height = targetHeight + 'px';
        img.style.transform = 'translate(-50%, -50%)'; // ì¤‘ì‹¬ ì •ë ¬
        
        // ğŸ”‘ ì´ˆê¸° ìœ„ì¹˜ë¥¼ data ì†ì„±ìœ¼ë¡œ ì €ì¥ (ìœ„ì¹˜ ì´ˆê¸°í™” ê¸°ëŠ¥ìš©)
        img.dataset.initialLeft = leftPercent + '%';
        img.dataset.initialTop = topPercent + '%';
        img.dataset.initialPositionSet = 'true'; // ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • ì™„ë£Œ í”Œë˜ê·¸
        
        const quadrantNames = ['NE', 'NW', 'SE', 'SW'];
        console.log(`  ì‚¬ë¶„ë©´: ${quadrantNames[quadrantIndex]}`);
        console.log(`  ìœ„ì¹˜: ${leftPercent.toFixed(2)}%, ${topPercent.toFixed(2)}%`);
        console.log(`  ì´ë¯¸ì§€ í¬ê¸°: ${targetWidth.toFixed(1)}px Ã— ${targetHeight.toFixed(1)}px (right_circle í¬ê¸° ë¹„ë¡€)`);
        console.log(`  ê²½ê³„ ì²´í¬: ${isWithinCircle ? 'âœ…' : 'âš ï¸'} ì›í˜• ê²½ê³„ ë‚´ë¶€, ì¤‘ì‹¬ ê±°ë¦¬=${finalDistanceFromCenter.toFixed(1)}px`);
        
        // ìµœì¢… ë°°ì¹˜ í›„ ì‹¤ì œ ìœ„ì¹˜ í™•ì¸ (ì´ë¯¸ì§€ê°€ ë Œë”ë§ëœ í›„)
        setTimeout(() => {
          const imgRect = img.getBoundingClientRect();
          const imgLeft = imgRect.left - ticketContentRect.left;
          const imgTop = imgRect.top - ticketContentRect.top;
          const imgRight = imgLeft + imgRect.width;
          const imgBottom = imgTop + imgRect.height;
          
          const actuallyWithinBounds = 
            imgLeft >= circleLeft && 
            imgRight <= circleRight && 
            imgTop >= circleTop && 
            imgBottom <= circleBottom;
          
          if (!actuallyWithinBounds) {
            console.error(`âŒâŒâŒ ê²½ê³„ ìœ„ë°˜! ì´ë¯¸ì§€ ${index + 1}ì´ ì‹¤ì œë¡œ right_circleë¥¼ ë„˜ìŠµë‹ˆë‹¤!`);
            console.error(`  right_circle: left=${circleLeft.toFixed(1)}, right=${circleRight.toFixed(1)}, top=${circleTop.toFixed(1)}, bottom=${circleBottom.toFixed(1)}`);
            console.error(`  ì´ë¯¸ì§€ ì‹¤ì œ ìœ„ì¹˜: left=${imgLeft.toFixed(1)}, right=${imgRight.toFixed(1)}, top=${imgTop.toFixed(1)}, bottom=${imgBottom.toFixed(1)}`);
          } else {
            console.log(`âœ… ì´ë¯¸ì§€ ${index + 1}ì´ right_circle ë‚´ë¶€ì— ì •í™•íˆ ë°°ì¹˜ë¨`);
          }
        }, 100);
        
        // ë“œë˜ê·¸ ê¸°ëŠ¥ ì ìš©
        makeImageDraggable(img);
      };
      
      // ì´ë¯¸ì§€ê°€ ì´ë¯¸ ë¡œë“œë˜ì—ˆìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰, ì•„ë‹ˆë©´ ë¡œë“œ ì™„ë£Œ í›„ ì‹¤í–‰ (í•œ ë²ˆë§Œ ì‹¤í–‰)
      let positionUpdated = false;
      const updateOnce = () => {
        if (!positionUpdated) {
          positionUpdated = true;
          updateImagePosition();
          // load ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° (í•œ ë²ˆë§Œ ì‹¤í–‰)
          img.removeEventListener('load', updateOnce);
        }
      };
      
      if (img.complete && img.naturalWidth > 0) {
        updateOnce();
      } else {
        img.addEventListener('load', updateOnce, { once: true });
      }
    });
    
    // ì•…ê¸° ê·¸ë˜í”½ ì¼ë ¬ ë°°ì¹˜ (ì˜¤ë¥¸ìª½ ì¨í´ ì•„ë˜ìª½)
    // ë¨¼ì € ëª¨ë“  ì•…ê¸° ì´ë¯¸ì§€ì˜ í¬ê¸°ë¥¼ ê³„ì‚°í•˜ì—¬ ì €ì¥ (ì¶©ëŒ ì²´í¬ë¥¼ ìœ„í•´)
    const instrumentSizes = [];
    instrumentImages.forEach((img, index) => {
      const originalWidth = img.naturalWidth;
      const originalHeight = img.naturalHeight;
      const aspectRatio = originalHeight / originalWidth;
      const usableReferenceSize = Math.min(usableWidth, usableHeight);
      
      // ì•…ê¸°ë³„ í¬ê¸° ì¡°ì •
      const imgSrc = img.src || '';
      const imgAlt = img.alt || '';
      let instrumentScale = 1.0;
      
      if (imgSrc.includes('Cb.svg') || imgSrc.includes('/Cb.') || /ì½˜íŠ¸ë¼ë² ì´ìŠ¤|ì½˜íŠ¸ë² ì´ìŠ¤/.test(imgAlt)) {
        instrumentScale = 1.15;
      } else if (imgSrc.includes('Vn.svg') || imgSrc.includes('/Vn.') || /ë°”ì´ì˜¬ë¦°/.test(imgAlt)) {
        instrumentScale = 0.70;
      } else if (imgSrc.includes('Vla.svg') || imgSrc.includes('/Vla.') || /ë¹„ì˜¬ë¼/.test(imgAlt)) {
        instrumentScale = 0.80;
      } else if (imgSrc.includes('Tp.svg') || imgSrc.includes('/Tp.') || /íŠ¸ëŸ¼í«/.test(imgAlt)) {
        instrumentScale = 0.75;
      } else if (imgSrc.includes('Trb.svg') || imgSrc.includes('/Trb.') || /íŠ¸ë¡¬ë³¸|íŠ¸ëŸ¼ë³¸/.test(imgAlt)) {
        instrumentScale = 0.75;
      } else if (imgSrc.includes('Hn.svg') || imgSrc.includes('/Hn.') || /í˜¸ë¥¸/.test(imgAlt)) {
        instrumentScale = 0.75;
      }
      
      const baseScale = img.dataset.scale ? parseFloat(img.dataset.scale) : 0.5;
      const targetSizeRatio = baseScale * 1.50 * instrumentScale;
      const targetSize = usableReferenceSize * targetSizeRatio;
      
      let targetWidth, targetHeight;
      if (originalWidth > originalHeight) {
        targetWidth = targetSize;
        targetHeight = targetSize * aspectRatio;
      } else {
        targetHeight = targetSize;
        targetWidth = targetSize / aspectRatio;
      }
      
      // í¬ê¸° ì œí•œ ì ìš© (ê°„ë‹¨í•œ ë²„ì „)
      if (targetWidth > maxImageSize || targetHeight > maxImageSize) {
        const scaleByWidth = maxImageSize / targetWidth;
        const scaleByHeight = maxImageSize / targetHeight;
        const finalScale = Math.min(scaleByWidth, scaleByHeight);
        targetWidth *= finalScale;
        targetHeight *= finalScale;
      }
      
      instrumentSizes.push({ width: targetWidth, height: targetHeight, halfWidth: targetWidth / 2, halfHeight: targetHeight / 2 });
    });
    
    // ëª¨ë“  ì•…ê¸° ì´ë¯¸ì§€ì˜ ìœ„ì¹˜ë¥¼ ë¨¼ì € ìˆœì°¨ì ìœ¼ë¡œ ê³„ì‚° (ì¶©ëŒ ì²´í¬ë¥¼ ìœ„í•´)
    const instrumentPositions = [];
    let currentX = usableLeft + usableWidth * 0.15; // ì´ˆê¸° X ìœ„ì¹˜
    const minSpacingRatio = 0.20; // ìµœì†Œ ê°„ê²© ë¹„ìœ¨ (20%)
    
    instrumentImages.forEach((img, index) => {
      const size = instrumentSizes[index];
      const minSpacing = Math.max(size.width, size.height) * minSpacingRatio;
      
      // ì´ì „ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ê°„ê²© í™•ë³´
      if (index > 0) {
        const prevSize = instrumentSizes[index - 1];
        const prevPos = instrumentPositions[index - 1];
        const minGap = prevSize.halfWidth + size.halfWidth + minSpacing;
        currentX = Math.max(currentX, prevPos.x + minGap);
      }
      
      instrumentPositions.push({
        x: currentX,
        y: baseY,
        width: size.width,
        height: size.height,
        halfWidth: size.halfWidth,
        halfHeight: size.halfHeight
      });
      
      console.log(`ğŸ“ ì•…ê¸° ${index + 1} ìœ„ì¹˜ ê³„ì‚°: x=${currentX.toFixed(1)}px, í¬ê¸°=${size.width.toFixed(1)}x${size.height.toFixed(1)}px`);
      
      // ë‹¤ìŒ ì´ë¯¸ì§€ë¥¼ ìœ„í•œ X ìœ„ì¹˜ ì—…ë°ì´íŠ¸
      currentX = currentX + size.width + minSpacing;
    });
    
    // ì´ì œ ì´ë¯¸ì§€ë“¤ì„ ìˆœì°¨ì ìœ¼ë¡œ ë°°ì¹˜ (ê³„ì‚°ëœ ìœ„ì¹˜ ì‚¬ìš©)
    instrumentImages.forEach((img, index) => {
      console.log(`ğŸ“¦ ì•…ê¸° ê·¸ë˜í”½ ${index + 1}ë²ˆì§¸ ì´ë¯¸ì§€ ì²˜ë¦¬:`, img.src.split('/').pop());
      
      // ì´ë¯¸ì§€ê°€ ì™„ì „íˆ ë¡œë“œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„ í¬ê¸° í™•ì¸
      const updateImagePosition = () => {
        // ë“œë˜ê·¸ ì¤‘ì¼ ë•ŒëŠ” ìœ„ì¹˜ ì¬ì„¤ì •í•˜ì§€ ì•ŠìŒ
        if (img.dataset.isDragging === 'true') {
          console.log('â­ï¸ ë“œë˜ê·¸ ì¤‘ - ìœ„ì¹˜ ì¬ì„¤ì • ê±´ë„ˆëœ€');
          return;
        }
        
        // ì´ˆê¸° ìœ„ì¹˜ê°€ ì´ë¯¸ ì„¤ì •ë˜ì—ˆê³ , ì‚¬ìš©ìê°€ ì§ì ‘ ë“œë˜ê·¸í•œ ê²½ìš° ìœ„ì¹˜ ì¬ì„¤ì •í•˜ì§€ ì•ŠìŒ
        if (img.dataset.initialPositionSet === 'true' && img.dataset.userMoved === 'true') {
          console.log('â­ï¸ ì‚¬ìš©ìê°€ ì§ì ‘ ì´ë™ì‹œí‚¨ ì´ë¯¸ì§€ - ìœ„ì¹˜ ì¬ì„¤ì • ê±´ë„ˆëœ€');
          return;
        }
        
        // ì¼ë ¬ ë°°ì¹˜ ìœ„ì¹˜ ê³„ì‚° (ì˜¤ë¥¸ìª½ ì¨í´ ì•„ë˜ìª½) - ë¯¸ë¦¬ ê³„ì‚°ëœ ìœ„ì¹˜ ì‚¬ìš©
        const calculatedPos = instrumentPositions[index];
        const pos = {
          x: calculatedPos.x,
          y: calculatedPos.y
        };
        
        // ì›ë³¸ ì´ë¯¸ì§€ í¬ê¸°
        const originalWidth = img.naturalWidth;
        const originalHeight = img.naturalHeight;
        const aspectRatio = originalHeight / originalWidth;
        
        // ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ì—­ì„ ê¸°ì¤€ìœ¼ë¡œ í¬ê¸° ê³„ì‚°
        const usableReferenceSize = Math.min(usableWidth, usableHeight);
        
        // ì•…ê¸°ë³„ í¬ê¸° ì¡°ì • (ì½˜íŠ¸ë¼ë² ì´ìŠ¤ì™€ ê´€ì•…ê¸°ëŠ” ë” ì‘ê²Œ)
        const imgSrc = img.src || '';
        const imgAlt = img.alt || '';
        let instrumentScale = 1.0;
        
        // ì½˜íŠ¸ë¼ë² ì´ìŠ¤ëŠ” ì‚´ì§ í¬ê²Œ (115%)
        if (imgSrc.includes('Cb.svg') || imgSrc.includes('/Cb.') || /ì½˜íŠ¸ë¼ë² ì´ìŠ¤|ì½˜íŠ¸ë² ì´ìŠ¤/.test(imgAlt)) {
          instrumentScale = 1.15;
        }
        // ë°”ì´ì˜¬ë¦°ì€ ì‘ê²Œ (70% í¬ê¸°), ë¹„ì˜¬ë¼ëŠ” ì•½ê°„ ì‘ê²Œ (80% í¬ê¸°)
        else if (imgSrc.includes('Vn.svg') || imgSrc.includes('/Vn.') || /ë°”ì´ì˜¬ë¦°/.test(imgAlt)) {
          instrumentScale = 0.70;
        }
        else if (imgSrc.includes('Vla.svg') || imgSrc.includes('/Vla.') || /ë¹„ì˜¬ë¼/.test(imgAlt)) {
          instrumentScale = 0.80;
        }
        // ê´€ì•…ê¸°(íŠ¸ëŸ¼í«, íŠ¸ë¡¬ë³¸, í˜¸ë¥¸)ë„ ë” ì‘ê²Œ (75% í¬ê¸°)
        else if (imgSrc.includes('Tp.svg') || imgSrc.includes('/Tp.') || /íŠ¸ëŸ¼í«/.test(imgAlt)) {
          instrumentScale = 0.75;
        }
        else if (imgSrc.includes('Trb.svg') || imgSrc.includes('/Trb.') || /íŠ¸ë¡¬ë³¸|íŠ¸ëŸ¼ë³¸/.test(imgAlt)) {
          instrumentScale = 0.75;
        }
        else if (imgSrc.includes('Hn.svg') || imgSrc.includes('/Hn.') || /í˜¸ë¥¸/.test(imgAlt)) {
          instrumentScale = 0.75;
        }
        // ë‹¤ë¥¸ ì•…ê¸°ëŠ” ê¸°ë³¸ í¬ê¸°
        else {
          instrumentScale = 1.0;
        }
        
        // baseScaleì„ ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ì—­ì˜ ì§ì ‘ ë¹„ìœ¨ë¡œ ë³€í™˜
        const baseScale = img.dataset.scale ? parseFloat(img.dataset.scale) : 0.5;
        const targetSizeRatio = baseScale * 1.50 * instrumentScale; // ì•…ê¸°ë³„ ìŠ¤ì¼€ì¼ ì ìš© (1.35â†’1.50)
        const targetSize = usableReferenceSize * targetSizeRatio;
        
        // ì›ë³¸ ì´ë¯¸ì§€ ë¹„ìœ¨ ìœ ì§€í•˜ë©´ì„œ targetSizeì— ë§ì¶”ê¸°
        let targetWidth, targetHeight;
        if (originalWidth > originalHeight) {
          // ê°€ë¡œê°€ ë” ê¸´ ê²½ìš°
          targetWidth = targetSize;
          targetHeight = targetSize * aspectRatio;
        } else {
          // ì„¸ë¡œê°€ ë” ê¸´ ê²½ìš°
          targetHeight = targetSize;
          targetWidth = targetSize / aspectRatio;
        }
        
        // ìµœëŒ€ í¬ê¸° ì œí•œ (ì ˆëŒ€ì ì¸ ì œí•œ)
        if (targetWidth > maxImageSize || targetHeight > maxImageSize) {
          const scaleByWidth = maxImageSize / targetWidth;
          const scaleByHeight = maxImageSize / targetHeight;
          const finalScale = Math.min(scaleByWidth, scaleByHeight);
          targetWidth *= finalScale;
          targetHeight *= finalScale;
        }
        
        // ë°˜ë“œì‹œ ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ì—­ ë‚´ì— ë“¤ì–´ê°€ë„ë¡ ì¶”ê°€ ê²€ì¦
        // ì•…ê¸° ê·¸ë˜í”½ì€ ì›í˜• ê²½ê³„ë¥¼ ê³ ë ¤í•˜ì—¬ ë” ë³´ìˆ˜ì ìœ¼ë¡œ í¬ê¸° ì œí•œ
        const halfWidth = targetWidth / 2;
        const halfHeight = targetHeight / 2;
        
        // ì›í˜• ê²½ê³„ë¥¼ ê³ ë ¤í•œ ìµœëŒ€ í¬ê¸° ê³„ì‚° (ë” ë³´ìˆ˜ì ìœ¼ë¡œ)
        const circleRadiusX = circleWidth / 2;
        const circleRadiusY = circleHeight / 2;
        const safeRadiusRatio = 0.65; // 65% ì•ˆì „ ë§ˆì§„ìœ¼ë¡œ ë§¤ìš° ë³´ìˆ˜ì ìœ¼ë¡œ (ì› ê²½ê³„ì—ì„œ ì¶©ë¶„íˆ ë–¨ì–´ì§„ ìœ„ì¹˜)
        
        // ì›í˜• ë‚´ë¶€ì— ì•ˆì „í•˜ê²Œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ìµœëŒ€ í¬ê¸° ê³„ì‚°
        const maxSafeWidth = circleRadiusX * safeRadiusRatio * 2; // ê°€ë¡œ ìµœëŒ€ í¬ê¸°
        const maxSafeHeight = circleRadiusY * safeRadiusRatio * 2; // ì„¸ë¡œ ìµœëŒ€ í¬ê¸°
        
        // íƒ€ê²Ÿ í¬ê¸°ê°€ ì•ˆì „ ë²”ìœ„ë¥¼ ë„˜ìœ¼ë©´ ë” ì¤„ì„
        if (targetWidth > maxSafeWidth || targetHeight > maxSafeHeight) {
          const scaleBySafeWidth = maxSafeWidth / targetWidth;
          const scaleBySafeHeight = maxSafeHeight / targetHeight;
          const safeScale = Math.min(scaleBySafeWidth, scaleBySafeHeight);
          targetWidth *= safeScale;
          targetHeight *= safeScale;
        }
        
        // ìµœì¢… ê²€ì¦: í¬ê¸°ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ì—­ë³´ë‹¤ í¬ë©´ ë” ì¤„ì„ (ë” ë³´ìˆ˜ì ìœ¼ë¡œ)
        if (targetWidth > usableWidth || targetHeight > usableHeight) {
          const scaleByUsableWidth = usableWidth * 0.65 / targetWidth; // 65%ë¡œ ë§¤ìš° ì•ˆì „í•˜ê²Œ
          const scaleByUsableHeight = usableHeight * 0.65 / targetHeight; // 65%ë¡œ ë§¤ìš° ì•ˆì „í•˜ê²Œ
          const safetyScale = Math.min(scaleByUsableWidth, scaleByUsableHeight);
          targetWidth *= safetyScale;
          targetHeight *= safetyScale;
        }
        
        // halfWidth, halfHeight ì¬ê³„ì‚° (í¬ê¸° ì¡°ì • í›„)
        const finalHalfWidth = targetWidth / 2;
        const finalHalfHeight = targetHeight / 2;
        
        // ì›í˜• ê²½ê³„ë¥¼ ì ˆëŒ€ ë„˜ì§€ ì•Šë„ë¡ ì—„ê²©í•˜ê²Œ ì²´í¬ (ìµœìš°ì„ )
        // ë¨¼ì € ì›í˜• ê²½ê³„ ë‚´ë¶€ì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ìœ„ì¹˜ë¡œ ì¡°ì •
        let finalX = pos.x;
        let finalY = pos.y;
        
        // ì›í˜• ê²½ê³„ ë‚´ë¶€ì— ì•ˆì „í•˜ê²Œ ë°°ì¹˜ë˜ë„ë¡ ì—„ê²©í•˜ê²Œ ì²´í¬ (ìµœìš°ì„ )
        let maxIterations = 20;
        let iteration = 0;
        
        // ì›í˜• ê²½ê³„ ì²´í¬ ë¨¼ì € ìˆ˜í–‰
        while (iteration < maxIterations) {
          const checkPoints = [
            { x: finalX - finalHalfWidth, y: finalY - finalHalfHeight }, // ì¢Œìƒë‹¨
            { x: finalX + finalHalfWidth, y: finalY - finalHalfHeight }, // ìš°ìƒë‹¨
            { x: finalX - finalHalfWidth, y: finalY + finalHalfHeight }, // ì¢Œí•˜ë‹¨
            { x: finalX + finalHalfWidth, y: finalY + finalHalfHeight }  // ìš°í•˜ë‹¨
          ];
          
          let needsAdjustment = false;
          let adjustX = 0;
          let adjustY = 0;
          
          checkPoints.forEach(point => {
            // íƒ€ì› ë‚´ë¶€ ì²´í¬: (x-cx)Â²/aÂ² + (y-cy)Â²/bÂ² <= 1
            const dx = (point.x - circleCenterX) / circleRadiusX;
            const dy = (point.y - circleCenterY) / circleRadiusY;
            const distSquared = dx * dx + dy * dy;
            
            // ì› ê²½ê³„ë¥¼ ì ˆëŒ€ ë„˜ì§€ ì•Šë„ë¡ ì—„ê²©í•˜ê²Œ ì²´í¬ (85% ì•ˆì „ ë§ˆì§„)
            if (distSquared > 0.85) {
              needsAdjustment = true;
              // ì› ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™í•˜ëŠ” ë°©í–¥ìœ¼ë¡œ ì¡°ì •
              const angle = Math.atan2(point.y - circleCenterY, point.x - circleCenterX);
              const maxDistX = circleRadiusX * 0.85 * Math.cos(angle);
              const maxDistY = circleRadiusY * 0.85 * Math.sin(angle);
              
              // ê° ëª¨ì„œë¦¬ì— ë”°ë¼ ì´ë¯¸ì§€ ì¤‘ì‹¬ì„ ì¡°ì •
              if (point === checkPoints[0] || point === checkPoints[2]) { // ì¢Œì¸¡ ëª¨ì„œë¦¬
                const desiredX = circleCenterX + maxDistX + finalHalfWidth;
                adjustX = Math.min(adjustX, (desiredX - finalX) * 0.8);
              }
              if (point === checkPoints[1] || point === checkPoints[3]) { // ìš°ì¸¡ ëª¨ì„œë¦¬
                const desiredX = circleCenterX + maxDistX - finalHalfWidth;
                adjustX = Math.max(adjustX, (desiredX - finalX) * 0.8);
              }
              if (point === checkPoints[0] || point === checkPoints[1]) { // ìƒë‹¨ ëª¨ì„œë¦¬
                const desiredY = circleCenterY + maxDistY + finalHalfHeight;
                adjustY = Math.min(adjustY, (desiredY - finalY) * 0.8);
              }
              if (point === checkPoints[2] || point === checkPoints[3]) { // í•˜ë‹¨ ëª¨ì„œë¦¬
                const desiredY = circleCenterY + maxDistY - finalHalfHeight;
                adjustY = Math.max(adjustY, (desiredY - finalY) * 0.8);
              }
            }
          });
          
          if (!needsAdjustment) break;
          
          finalX += adjustX;
          finalY += adjustY;
          iteration++;
        }
        
        // ì›í˜• ê²½ê³„ ì²´í¬ ì™„ë£Œ í›„, ì›í˜• ë‚´ë¶€ì—ì„œ ì¶©ëŒ ì²´í¬ ë° ìµœì†Œ ê°„ê²© í™•ë³´
        const minSpacing = Math.max(targetWidth, targetHeight) * 0.12; // ê°„ê²©ì„ 20%ì—ì„œ 12%ë¡œ ì¤„ì„
        
        // ì•ì„œ ë°°ì¹˜ëœ ì•…ê¸° ì´ë¯¸ì§€ë“¤ê³¼ ì¶©ëŒ ì²´í¬ (ì›í˜• ê²½ê³„ ë‚´ë¶€ì—ì„œë§Œ)
        for (let i = 0; i < index; i++) {
          const prevImg = instrumentImages[i];
          
          let prevCenterX, prevHalfWidth;
          
          const prevRect = prevImg.getBoundingClientRect();
          const ticketContentRectCurrent = ticketContent.getBoundingClientRect();
          
          if (prevRect.width > 0 && prevImg.style.width) {
            prevCenterX = prevRect.left - ticketContentRectCurrent.left + prevRect.width / 2;
            prevHalfWidth = prevRect.width / 2;
          } else {
            const prevPos = instrumentPositions[i];
            const prevSize = instrumentSizes[i];
            prevCenterX = prevPos.x;
            prevHalfWidth = prevSize.halfWidth;
          }
          
          // ê°€ë¡œ ë°©í–¥ ì¶©ëŒ ì²´í¬ (ìµœì†Œ ê°„ê²© í™•ë³´)
          const minHorizontalGap = finalHalfWidth + prevHalfWidth + minSpacing;
          const horizontalDistance = finalX - prevCenterX;
          
          if (horizontalDistance < minHorizontalGap) {
            const newX = prevCenterX + minHorizontalGap;
            
            // ìƒˆ ìœ„ì¹˜ê°€ ì›í˜• ê²½ê³„ ë‚´ë¶€ì¸ì§€ í™•ì¸
            const newLeft = newX - finalHalfWidth;
            const newRight = newX + finalHalfWidth;
            const newTop = finalY - finalHalfHeight;
            const newBottom = finalY + finalHalfHeight;
            
            const newCheckPoints = [
              { x: newLeft, y: newTop },
              { x: newRight, y: newTop },
              { x: newLeft, y: newBottom },
              { x: newRight, y: newBottom }
            ];
            
            let allPointsInside = true;
            for (const point of newCheckPoints) {
              const dx = (point.x - circleCenterX) / circleRadiusX;
              const dy = (point.y - circleCenterY) / circleRadiusY;
              const distSquared = dx * dx + dy * dy;
              if (distSquared > 0.85) {
                allPointsInside = false;
                break;
              }
            }
            
            // ì›í˜• ê²½ê³„ ë‚´ë¶€ì— ë“¤ì–´ê°€ë©´ ìœ„ì¹˜ ì¡°ì •, ì•„ë‹ˆë©´ í˜„ì¬ ìœ„ì¹˜ ìœ ì§€
            if (allPointsInside) {
              finalX = newX;
              console.log(`  ğŸ”„ ì•…ê¸° ${index + 1} ìœ„ì¹˜ ì¡°ì • (ì´ì „ ì´ë¯¸ì§€ì™€ ê°„ê²© í™•ë³´, ì›í˜• ë‚´ë¶€): ${pos.x.toFixed(1)} â†’ ${finalX.toFixed(1)}px`);
            } else {
              console.log(`  âš ï¸ ì•…ê¸° ${index + 1} ìœ„ì¹˜ ì¡°ì • ì·¨ì†Œ (ì›í˜• ê²½ê³„ë¥¼ ë„˜ìŒ): í˜„ì¬ ìœ„ì¹˜ ìœ ì§€`);
            }
          }
        }
        
        // ìµœì¢… ê²½ê³„ ê²€ì¦ (ì‚¬ê°í˜• ê²½ê³„ë„ ì²´í¬)
        const finalLeft = finalX - finalHalfWidth;
        const finalRight = finalX + finalHalfWidth;
        const finalTop = finalY - finalHalfHeight;
        const finalBottom = finalY + finalHalfHeight;
        
        // ì‚¬ê°í˜• ê²½ê³„ ë‚´ë¶€ í™•ì¸ (ì›ì˜ ì™¸ì ‘ ì‚¬ê°í˜•)
        const isWithinRect = 
          finalLeft >= circleLeft && 
          finalRight <= circleRight && 
          finalTop >= circleTop && 
          finalBottom <= circleBottom;
        
        if (!isWithinRect) {
          console.warn(`âš ï¸ ì•…ê¸° ì´ë¯¸ì§€ê°€ ì‚¬ê°í˜• ê²½ê³„ë¥¼ ë„˜ìŒ, ìœ„ì¹˜ ì¬ì¡°ì •`);
          // ì‚¬ê°í˜• ê²½ê³„ë¡œ ê°•ì œ ì¡°ì • (finalHalfWidth, finalHalfHeight ì‚¬ìš©)
          if (finalLeft < circleLeft) finalX = circleLeft + finalHalfWidth;
          if (finalRight > circleRight) finalX = circleRight - finalHalfWidth;
          if (finalTop < circleTop) finalY = circleTop + finalHalfHeight;
          if (finalBottom > circleBottom) finalY = circleBottom - finalHalfHeight;
        }
        
        // í¼ì„¼íŠ¸ë¡œ ë³€í™˜
        let leftPercent = (finalX / ticketContentRect.width) * 100;
        let topPercent = (finalY / ticketContentRect.height) * 100;
        
        console.log(`  ğŸ“ ì•…ê¸° ê·¸ë˜í”½ ìµœì¢… ìœ„ì¹˜ ê³„ì‚°: finalX=${finalX.toFixed(1)}px, finalY=${finalY.toFixed(1)}px â†’ left=${leftPercent.toFixed(2)}%, top=${topPercent.toFixed(2)}%`);
        
        img.style.left = leftPercent + '%';
        img.style.top = topPercent + '%';
        img.style.width = targetWidth + 'px';
        img.style.height = targetHeight + 'px';
        img.style.transform = 'translate(-50%, -50%)'; // ì¤‘ì‹¬ ì •ë ¬
        
        // ğŸ”‘ ì´ˆê¸° ìœ„ì¹˜ë¥¼ data ì†ì„±ìœ¼ë¡œ ì €ì¥ (ìœ„ì¹˜ ì´ˆê¸°í™” ê¸°ëŠ¥ìš©)
        img.dataset.initialLeft = leftPercent + '%';
        img.dataset.initialTop = topPercent + '%';
        img.dataset.initialPositionSet = 'true'; // ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • ì™„ë£Œ í”Œë˜ê·¸
        
        console.log(`  ì¼ë ¬ ë°°ì¹˜: ì•…ê¸° ê·¸ë˜í”½ ${index + 1}ë²ˆì§¸ ì´ë¯¸ì§€`);
        console.log(`  ìœ„ì¹˜: ${leftPercent.toFixed(2)}%, ${topPercent.toFixed(2)}%`);
        console.log(`  ì´ë¯¸ì§€ í¬ê¸°: ${targetWidth.toFixed(1)}px Ã— ${targetHeight.toFixed(1)}px (right_circle í¬ê¸° ë¹„ë¡€)`);
        console.log(`  ê²½ê³„ ì²´í¬: ${isWithinRect ? 'âœ…' : 'âš ï¸'} left=${finalLeft.toFixed(1)} ~ ${finalRight.toFixed(1)}, top=${finalTop.toFixed(1)} ~ ${finalBottom.toFixed(1)}`);
        
        // ìµœì¢… ë°°ì¹˜ í›„ ì‹¤ì œ ìœ„ì¹˜ í™•ì¸ (ì´ë¯¸ì§€ê°€ ë Œë”ë§ëœ í›„)
        setTimeout(() => {
          const imgRect = img.getBoundingClientRect();
          const imgLeft = imgRect.left - ticketContentRect.left;
          const imgTop = imgRect.top - ticketContentRect.top;
          const imgRight = imgLeft + imgRect.width;
          const imgBottom = imgTop + imgRect.height;
          
          const actuallyWithinBounds = 
            imgLeft >= circleLeft && 
            imgRight <= circleRight && 
            imgTop >= circleTop && 
            imgBottom <= circleBottom;
          
          if (!actuallyWithinBounds) {
            console.error(`âŒâŒâŒ ê²½ê³„ ìœ„ë°˜! ì•…ê¸° ì´ë¯¸ì§€ ${index + 1}ì´ ì‹¤ì œë¡œ right_circleë¥¼ ë„˜ìŠµë‹ˆë‹¤!`);
            console.error(`  ì‹¤ì œ ì´ë¯¸ì§€ ë²”ìœ„: ${imgLeft.toFixed(1)} ~ ${imgRight.toFixed(1)}, ${imgTop.toFixed(1)} ~ ${imgBottom.toFixed(1)}`);
            console.error(`  right_circle ë²”ìœ„: ${circleLeft.toFixed(1)} ~ ${circleRight.toFixed(1)}, ${circleTop.toFixed(1)} ~ ${circleBottom.toFixed(1)}`);
          } else {
            console.log(`âœ… ì•…ê¸° ì´ë¯¸ì§€ ${index + 1} ê²½ê³„ í™•ì¸ ì™„ë£Œ: right_circle ë‚´ë¶€ì— ì •í™•íˆ ë°°ì¹˜ë¨`);
          }
        }, 100);
        
        // ë“œë˜ê·¸ ê¸°ëŠ¥ ì ìš©
        makeImageDraggable(img);
      };
      
      // ì´ë¯¸ì§€ê°€ ì´ë¯¸ ë¡œë“œë˜ì—ˆìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰, ì•„ë‹ˆë©´ ë¡œë“œ ì™„ë£Œ í›„ ì‹¤í–‰ (í•œ ë²ˆë§Œ ì‹¤í–‰)
      let positionUpdated = false;
      const updateOnce = () => {
        if (!positionUpdated) {
          positionUpdated = true;
        updateImagePosition();
          // load ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° (í•œ ë²ˆë§Œ ì‹¤í–‰)
          img.removeEventListener('load', updateOnce);
        }
      };
      
      if (img.complete && img.naturalWidth > 0) {
        updateOnce();
      } else {
        img.addEventListener('load', updateOnce, { once: true });
      }
    });
    
    console.log(`âœ… ë°°ì¹˜ ì™„ë£Œ! ì¼ë°˜ ê·¸ë˜í”½ ${regularImages.length}ê°œ (ì‚¬ë¶„ë©´ ë°°ì¹˜), ì•…ê¸° ê·¸ë˜í”½ ${instrumentImages.length}ê°œ (ì¼ë ¬ ë°°ì¹˜) - ì´ ${draggableImages.length}ê°œ ì´ë¯¸ì§€ (right_circle í¬ê¸°: ${circleWidth.toFixed(1)}px Ã— ${circleHeight.toFixed(1)}px)`);
  }

  // ğŸ¯ ì‹¤ì œ í‹°ì¼“ ì´ë¯¸ì§€ ì˜ì—­ ê³„ì‚° ë° ë“œë˜ê·¸ ê²½ê³„ ì„¤ì •
  function calculateTicketBoundary() {
    const ticketContent = document.getElementById('ticketContent');
    const ticketLeft = document.querySelector('.ticket-left');
    const ticketRight = document.querySelector('.ticket-right');
    
    if (!ticketContent || !ticketLeft || !ticketRight) {
      console.warn('í‹°ì¼“ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ ê¸°ë³¸ê°’ ì‚¬ìš©');
      return { 
        left: { minLeft: 0, maxLeft: 50, minTop: 0, maxTop: 100 },
        right: { minRight: 50, maxRight: 100, minTop: 0, maxTop: 100 }
      };
    }
    
    const contentRect = ticketContent.getBoundingClientRect();
    const leftRect = ticketLeft.getBoundingClientRect();
    const rightRect = ticketRight.getBoundingClientRect();
    
    // ì™¼ìª½ í‹°ì¼“ ì˜ì—­ ê²½ê³„
    const leftBoundary = {
      minLeft: ((leftRect.left - contentRect.left) / contentRect.width) * 100,
      maxLeft: ((leftRect.right - contentRect.left) / contentRect.width) * 100,
      minTop: ((leftRect.top - contentRect.top) / contentRect.height) * 100,
      maxTop: ((leftRect.bottom - contentRect.top) / contentRect.height) * 100
    };
    
    // ì˜¤ë¥¸ìª½ í‹°ì¼“ ì˜ì—­ ê²½ê³„ (right ì†ì„± ê¸°ì¤€)
    const rightBoundary = {
      minRight: ((contentRect.right - rightRect.right) / contentRect.width) * 100,
      maxRight: ((contentRect.right - rightRect.left) / contentRect.width) * 100,
      minTop: ((rightRect.top - contentRect.top) / contentRect.height) * 100,
      maxTop: ((rightRect.bottom - contentRect.top) / contentRect.height) * 100
    };
    
    console.log('ğŸ¯ í‹°ì¼“ ê²½ê³„ ê³„ì‚°:', { leftBoundary, rightBoundary });
    
    return { left: leftBoundary, right: rightBoundary };
  }

  // ë“œë˜ê·¸ ê¸°ëŠ¥ êµ¬í˜„
  function makeImageDraggable(img) {
    console.log('ğŸ”§ ë“œë˜ê·¸ ê¸°ëŠ¥ ì´ˆê¸°í™”:', img.src);
    
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    const ticketContent = document.getElementById('ticketContent');
    
    if (!ticketContent) {
      console.error('âŒ ticketContent ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
      return;
    }
    
    // ë“œë˜ê·¸ ê²½ê³„ëŠ” ê° ì´ë¯¸ì§€ íƒ€ì…ë³„ë¡œ ê°œë³„ ì„¤ì •
    console.log('ğŸ”§ ë“œë˜ê·¸ ê¸°ëŠ¥ ì´ˆê¸°í™” - ê²½ê³„ ê³„ì‚° ìƒëµ');
    
    // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° (ì¤‘ë³µ ë°©ì§€)
    img.removeEventListener('mousedown', img._dragMouseDown);
    document.removeEventListener('mousemove', img._dragMouseMove);
    document.removeEventListener('mouseup', img._dragMouseUp);
    
    let startRight = 0; // ì˜¤ë¥¸ìª½ ì´ë¯¸ì§€ì˜ ì´ˆê¸° right ìœ„ì¹˜
    let startRightTop = 0; // ì˜¤ë¥¸ìª½ ì´ë¯¸ì§€ì˜ ì´ˆê¸° top ìœ„ì¹˜
    
    img._dragMouseDown = function(e) {
      console.log('ğŸ–±ï¸ ë§ˆìš°ìŠ¤ ë‹¤ìš´ ì´ë²¤íŠ¸ ë°œìƒ');
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      img.dataset.isDragging = 'true'; // ë“œë˜ê·¸ ì¤‘ í”Œë˜ê·¸ ì„¤ì •
      startX = e.clientX;
      startY = e.clientY;
      
      // ğŸ¯ ì‹¤ì œ ë Œë”ë§ëœ ì´ë¯¸ì§€ ì¤‘ì‹¬ì ì„ ê¸°ì¤€ìœ¼ë¡œ ì •í™•í•œ ìœ„ì¹˜ ê³„ì‚°
      // transform: translate(-50%, -50%) ë•Œë¬¸ì— ì´ë¯¸ì§€ ì¤‘ì‹¬ì ì´ style.left/top ìœ„ì¹˜ì™€ ì¼ì¹˜
      const rect = ticketContent.getBoundingClientRect();
      const imgRect = img.getBoundingClientRect();
      
      // ì´ë¯¸ì§€ì˜ ì‹¤ì œ ì¤‘ì‹¬ì  (ë Œë”ë§ëœ ìœ„ì¹˜)
      const imgCenterX = imgRect.left + imgRect.width / 2;
      const imgCenterY = imgRect.top + imgRect.height / 2;
      
      // ticketContent ê¸°ì¤€ìœ¼ë¡œ í¼ì„¼íŠ¸ ë³€í™˜ (ì¤‘ì‹¬ì  ê¸°ì¤€)
      startLeft = ((imgCenterX - rect.left) / rect.width) * 100;
      startTop = ((imgCenterY - rect.top) / rect.height) * 100;
      
      // style ê°’ê³¼ ë¹„êµ (ë””ë²„ê¹…ìš©)
      const styleLeft = parseFloat(img.style.left) || 0;
      const styleTop = parseFloat(img.style.top) || 0;
      const diffLeft = Math.abs(startLeft - styleLeft);
      const diffTop = Math.abs(startTop - styleTop);
      
      console.log('ğŸ“ ë“œë˜ê·¸ ì‹œì‘ ìœ„ì¹˜ ê³„ì‚°:', {
        ì‹¤ì œìœ„ì¹˜: { left: startLeft.toFixed(2) + '%', top: startTop.toFixed(2) + '%' },
        styleê°’: { left: styleLeft.toFixed(2) + '%', top: styleTop.toFixed(2) + '%' },
        ì°¨ì´: { left: diffLeft.toFixed(2) + '%', top: diffTop.toFixed(2) + '%' },
        ì´ë¯¸ì§€ì¤‘ì‹¬: { x: imgCenterX.toFixed(1) + 'px', y: imgCenterY.toFixed(1) + 'px' },
        ì»¨í…Œì´ë„ˆ: { left: rect.left.toFixed(1) + 'px', top: rect.top.toFixed(1) + 'px', width: rect.width.toFixed(1) + 'px', height: rect.height.toFixed(1) + 'px' }
      });
      
      if (diffLeft > 1 || diffTop > 1) {
        console.warn('âš ï¸ ì‹¤ì œ ìœ„ì¹˜ì™€ style ê°’ì— ì°¨ì´ê°€ ìˆìŠµë‹ˆë‹¤!', { diffLeft, diffTop });
      }
      
      // ë“œë˜ê·¸ ì‹œì‘ ë¡œê·¸
      const currentIndex = img.dataset.index;
      console.log('ğŸ” ë“œë˜ê·¸ ì‹œì‘ - ì´ë¯¸ì§€ index:', currentIndex);
      
      // í´ë¦­í•œ ê·¸ë˜í”½ì˜ z-indexë¥¼ ì˜¬ë ¤ì„œ ê°€ì¥ ìœ„ì— í‘œì‹œ (ì•…ê¸° í¬í•¨)
      // ëª¨ë“  ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ì¤‘ì—ì„œ ìµœëŒ€ z-index ì°¾ê¸°
      const allDraggableImages = ticketContent.querySelectorAll('img[style*="cursor"]');
      let maxZIndex = 10; // ê¸°ë³¸ z-index ì‹œì‘ê°’
      
      allDraggableImages.forEach(otherImg => {
        const zIndex = parseInt(otherImg.style.zIndex) || 10;
        if (zIndex > maxZIndex) {
          maxZIndex = zIndex;
        }
      });
      
      // í˜„ì¬ ì´ë¯¸ì§€ì˜ z-indexë¥¼ ìµœëŒ€ê°’ë³´ë‹¤ 1 ë†’ê²Œ ì„¤ì •
      img.style.zIndex = (maxZIndex + 1).toString();
      console.log(`ğŸ“Œ z-index ì„¤ì •: ${img.style.zIndex}`);
      
      img.style.cursor = 'grabbing';
    };
    
    img._dragMouseMove = function(e) {
      if (!isDragging) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      // ticketContent ìœ„ì¹˜ê°€ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë§¤ë²ˆ ì¬ê³„ì‚°
      const rect = ticketContent.getBoundingClientRect();
      
      // ë§ˆìš°ìŠ¤ ì´ë™ëŸ‰ ê³„ì‚°
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      // í”½ì…€ì„ í¼ì„¼íŠ¸ë¡œ ë³€í™˜ (ticketContent ê¸°ì¤€)
      const deltaXPercent = (deltaX / rect.width) * 100;
      const deltaYPercent = (deltaY / rect.height) * 100;
      
      // ì‹œì‘ ìœ„ì¹˜ì—ì„œ ì´ë™ëŸ‰ë§Œí¼ ë”í•˜ê¸°
      let newLeft = startLeft + deltaXPercent;
      let newTop = startTop + deltaYPercent;
      
      // ì´ë¯¸ì§€ í¬ê¸° ê³„ì‚° (í¼ì„¼íŠ¸) - SVG ì›ë³¸ í¬ê¸° ì‚¬ìš©
      const imgWidthPercent = (img.offsetWidth / rect.width) * 100;
      const imgHeightPercent = (img.offsetHeight / rect.height) * 100;
      
      // ğŸ¯ right_circle ì˜ì—­ì„ ì ˆëŒ€ ë„˜ì§€ ì•Šë„ë¡ ê²½ê³„ ì œí•œ
      const rightCircleEl = document.getElementById('rightCircle');
      if (!rightCircleEl) {
        console.error('âŒ rightCircle ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
        return;
      }
      
      const ticketContentRect = ticketContent.getBoundingClientRect();
      const rightCircleRect = rightCircleEl.getBoundingClientRect();
      
      // right_circleì˜ ìœ„ì¹˜ (ticketContent ê¸°ì¤€)
      const circleLeft = rightCircleRect.left - ticketContentRect.left;
      const circleTop = rightCircleRect.top - ticketContentRect.top;
      const circleRight = circleLeft + rightCircleRect.width;
      const circleBottom = circleTop + rightCircleRect.height;
      
      // ì›í˜• ë“œë˜ê·¸ ì˜ì—­ ê³„ì‚°
      const circleCenterX = circleLeft + rightCircleRect.width / 2;
      const circleCenterY = circleTop + rightCircleRect.height / 2;
      const circleRadius = Math.min(rightCircleRect.width, rightCircleRect.height) / 2;
      
      // ì•…ê¸° ê·¸ë˜í”½ì¸ì§€ í™•ì¸
      const imgSrc = img.src || '';
      const imgAlt = img.alt || '';
      const isInstrument = imgSrc.includes('/instruments/') || /(ë°”ì´ì˜¬ë¦°|ë¹„ì˜¬ë¼|ì²¼ë¡œ|íŠ¸ëŸ¼ë³¸|íŠ¸ëŸ¼í«|í˜¸ë¥¸|í”Œë£»|í´ë¼ë¦¬ë„·|ì½˜íŠ¸ë¼ë² ì´ìŠ¤)/.test(imgAlt);
      
      // ì´ë¯¸ì§€ì˜ ì¤‘ì‹¬ì  ê¸°ì¤€ìœ¼ë¡œ ê²½ê³„ ê³„ì‚° (transform: translate(-50%, -50%) ì‚¬ìš©)
      const halfImgWidthPercent = imgWidthPercent / 2;
      const halfImgHeightPercent = imgHeightPercent / 2;
      
      // ì´ë¯¸ì§€ ì¤‘ì‹¬ì ì˜ í”½ì…€ ì¢Œí‘œ (ticketContent ê¸°ì¤€)
      const newLeftPx = (newLeft / 100) * ticketContentRect.width;
      const newTopPx = (newTop / 100) * ticketContentRect.height;
      
      // ì›í˜• ê²½ê³„ ì²´í¬: ì´ë¯¸ì§€ ì¤‘ì‹¬ì ì´ ì› ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
      const dx = newLeftPx - circleCenterX;
      const dy = newTopPx - circleCenterY;
      const distanceFromCenter = Math.sqrt(dx * dx + dy * dy);
      
      // ì´ë¯¸ì§€ì˜ ëŒ€ê°ì„  ë°˜ì§€ë¦„ ê³„ì‚° (ì›í˜• ê²½ê³„ë¥¼ ë„˜ì§€ ì•Šë„ë¡)
      const imgDiagonalRadius = Math.sqrt(
        (img.offsetWidth / 2) ** 2 + 
        (img.offsetHeight / 2) ** 2
      );
      
      // ğŸ¯ ì›í˜• ê²½ê³„ ì²´í¬: ë‹¨ìˆœí•˜ê²Œ ì´ë¯¸ì§€ ì¤‘ì‹¬ì ì´ ì› ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
      // ë§ˆì§„ì„ ì ì ˆíˆ ì¡°ì •í•´ì„œ ë“œë˜ê·¸ ë²”ìœ„ ì œê³µ
      const safeRadiusRatio = isInstrument ? 0.96 : 0.97; // ì•…ê¸°ëŠ” 96%, ì¼ë°˜ì€ 97% (ì ì ˆí•œ ë§ˆì§„)
      // imgDiagonalRadiusë¥¼ ì ì ˆíˆ ë°˜ì˜
      const maxAllowedDistance = circleRadius * safeRadiusRatio - (imgDiagonalRadius * 0.7);
      
      // ìƒë‹¨/í•˜ë‹¨ì€ ì¢Œìš° ë§ˆì§„ ë§ì´, ì¤‘ë‹¨ì€ ë§ˆì§„ ì—†ìŒìœ¼ë¡œ êµ¬ë¶„
      const yPercent = (newTopPx / ticketContentRect.height) * 100;
      const circleTopPercent = (circleTop / ticketContentRect.height) * 100;
      const circleBottomPercent = (circleBottom / ticketContentRect.height) * 100;
      const circleHeightPercent = circleBottomPercent - circleTopPercent;
      
      // ìƒë‹¨/ì¤‘ë‹¨/í•˜ë‹¨ êµ¬ë¶„ (33%ì”© ë‚˜ëˆ”)
      const topThreshold = circleTopPercent + circleHeightPercent * 0.33;
      const bottomThreshold = circleTopPercent + circleHeightPercent * 0.67;
      
      // ìƒí•˜ ë§ˆì§„ (ì ì ˆí•œ ë§ˆì§„)
      const verticalMargin = isInstrument ? circleRadius * 0.008 : circleRadius * 0.005;
      
      let horizontalMargin;
      if (yPercent < topThreshold) {
        // ìƒë‹¨: ì¢Œìš° ë§ˆì§„ (ì ì ˆí•œ ë§ˆì§„)
        horizontalMargin = isInstrument ? circleRadius * 0.02 : circleRadius * 0.012;
      } else if (yPercent > bottomThreshold) {
        // í•˜ë‹¨: ì¢Œìš° ë§ˆì§„ (ì ì ˆí•œ ë§ˆì§„)
        horizontalMargin = isInstrument ? circleRadius * 0.02 : circleRadius * 0.012;
      } else {
        // ì¤‘ë‹¨: ì¢Œìš° ë§ˆì§„ ì—†ìŒ
        horizontalMargin = 0;
      }
      
      // ì›í˜• ê²½ê³„ë¥¼ ë„˜ìœ¼ë©´ ì› ì•ˆìœ¼ë¡œ ì œí•œ
      if (distanceFromCenter > maxAllowedDistance) {
        // ì›ì˜ ê²½ê³„ë¡œ ì´ë™ (ì¤‘ì‹¬ì—ì„œ maxAllowedDistance ê±°ë¦¬ë§Œí¼)
        const angle = Math.atan2(dy, dx);
        const limitedX = circleCenterX + maxAllowedDistance * Math.cos(angle);
        const limitedY = circleCenterY + maxAllowedDistance * Math.sin(angle);
        
        newLeft = (limitedX / ticketContentRect.width) * 100;
        newTop = (limitedY / ticketContentRect.height) * 100;
        
        // ì œí•œ í›„ ìœ„ì¹˜ ì¬ê³„ì‚°
        const newLeftPxAfterLimit = (newLeft / 100) * ticketContentRect.width;
        const newTopPxAfterLimit = (newTop / 100) * ticketContentRect.height;
        const dyAfterLimit = newTopPxAfterLimit - circleCenterY;
        const yPercentAfterLimit = (newTopPxAfterLimit / ticketContentRect.height) * 100;
        
        // ìƒë‹¨/í•˜ë‹¨ì¸ ê²½ìš° ì¢Œìš° ë§ˆì§„ ì¶”ê°€ ì ìš©
        if (yPercentAfterLimit < topThreshold || yPercentAfterLimit > bottomThreshold) {
          const dxAfterLimit = newLeftPxAfterLimit - circleCenterX;
          const maxHorizontalDistance = Math.sqrt(maxAllowedDistance ** 2 - dyAfterLimit ** 2);
          const allowedMaxX = Math.max(0, maxHorizontalDistance - horizontalMargin);
          
          if (Math.abs(dxAfterLimit) > allowedMaxX) {
            if (dxAfterLimit > 0) {
              newLeft = ((circleCenterX + allowedMaxX) / ticketContentRect.width) * 100;
      } else {
              newLeft = ((circleCenterX - allowedMaxX) / ticketContentRect.width) * 100;
            }
          }
        }
      } else {
        // ì›í˜• ê²½ê³„ ë‚´ë¶€ì— ìˆì„ ë•Œë„ ìƒë‹¨/í•˜ë‹¨ì¸ ê²½ìš° ì¢Œìš° ë§ˆì§„ ì²´í¬
        if (yPercent < topThreshold || yPercent > bottomThreshold) {
          const maxHorizontalDistance = Math.sqrt(maxAllowedDistance ** 2 - dy ** 2);
          const allowedMaxX = Math.max(0, maxHorizontalDistance - horizontalMargin);
          
          if (Math.abs(dx) > allowedMaxX) {
            if (dx > 0) {
              newLeft = ((circleCenterX + allowedMaxX) / ticketContentRect.width) * 100;
            } else {
              newLeft = ((circleCenterX - allowedMaxX) / ticketContentRect.width) * 100;
            }
          }
        }
      }
      
      // ì¶”ê°€ ê²½ê³„ ì²´í¬: ìƒí•˜ ê²½ê³„ (ë§ˆì§„ ìµœì†Œí™”)
      // verticalMarginì„ í¼ì„¼íŠ¸ë¡œ ë³€í™˜ (í”½ì…€ì„ í¼ì„¼íŠ¸ë¡œ)
      const verticalMarginPercent = (verticalMargin / ticketContentRect.height) * 100;
      const circleTopPercentWithMargin = circleTopPercent + verticalMarginPercent;
      const circleBottomPercentWithMargin = circleBottomPercent - verticalMarginPercent;
      
      const minTop = circleTopPercentWithMargin + halfImgHeightPercent;
      const maxTop = circleBottomPercentWithMargin - halfImgHeightPercent;
      newTop = Math.max(minTop, Math.min(newTop, maxTop));
      
      console.log('ğŸ¯ ë“œë˜ê·¸ ê²½ê³„ (ì›í˜• ì˜ì—­, ìƒë‹¨/í•˜ë‹¨ ë§ˆì§„ ì ìš©):', { 
        circleCenter: `(${circleCenterX.toFixed(1)}, ${circleCenterY.toFixed(1)})`,
        circleRadius: circleRadius.toFixed(1),
        maxAllowedDistance: maxAllowedDistance.toFixed(1),
        imgDiagonalRadius: imgDiagonalRadius.toFixed(1),
        horizontalMargin: horizontalMargin.toFixed(1),
        verticalMargin: verticalMargin.toFixed(1),
        yPercent: yPercent.toFixed(2),
        zone: yPercent < topThreshold ? 'ìƒë‹¨' : (yPercent > bottomThreshold ? 'í•˜ë‹¨' : 'ì¤‘ë‹¨'),
        distanceFromCenter: distanceFromCenter.toFixed(1),
        newLeft: newLeft.toFixed(2), 
        newTop: newTop.toFixed(2) 
      });
      
      img.style.left = newLeft + '%';
      img.style.top = newTop + '%';
      img.dataset.userMoved = 'true'; // ì‚¬ìš©ìê°€ ì§ì ‘ ì´ë™ì‹œí‚´ í”Œë˜ê·¸
      
      // ë“œë˜ê·¸ ì™„ë£Œ - ë¡œê·¸ë§Œ ì¶œë ¥
      console.log(`âœ… ì´ë¯¸ì§€ ${img.dataset.index} ë“œë˜ê·¸ ì™„ë£Œ: left=${newLeft}%, top=${newTop}%`);
    };
    
    img._dragMouseUp = function(e) {
      if (isDragging) {
        isDragging = false;
        img.dataset.isDragging = 'false'; // ë“œë˜ê·¸ ì¢…ë£Œ í”Œë˜ê·¸ í•´ì œ
        img.style.cursor = 'move';
        
        // ìµœì¢… ìœ„ì¹˜ ë¡œê·¸
        console.log(`ì´ë¯¸ì§€ ${img.dataset.index} ìœ„ì¹˜: left=${img.style.left}, top=${img.style.top}`);
      }
    };
    
    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    img.addEventListener('mousedown', img._dragMouseDown);
    document.addEventListener('mousemove', img._dragMouseMove);
    document.addEventListener('mouseup', img._dragMouseUp);
    
    console.log('âœ… ë“œë˜ê·¸ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ì™„ë£Œ');
  }

  // ì‚¬ìš©ì ì„ íƒì— ë”°ë¥¸ ì‹¤ì œ ì´ë¯¸ì§€ í‘œì‹œ
  if (selectedValues.length > 0) {
    console.log('ì„ íƒëœ ê°’ë“¤ë¡œ ì´ë¯¸ì§€ ìƒì„±:', selectedValues);
    
    let imagesHTML = '';
    
    // ì‚¬ìš©ì ì„ íƒ í…ìŠ¤íŠ¸ ì¶”ê°€
    imagesHTML += generateUserText();
    
    selectedValues.forEach((value, index) => {
      const imageData = KEYWORD_IMAGES[value];
      if (imageData && index < 7) {  // ìµœëŒ€ 7ê°œê¹Œì§€ë§Œ
        // ì™¼ìª½/ì˜¤ë¥¸ìª½ ì´ë¯¸ì§€ ìœ„ì¹˜ ê°œë³„ ì„¤ì •
        const leftPos = IMAGE_POSITIONS.left[index];
        const rightPos = IMAGE_POSITIONS.right[index];
        
        console.log(`${index + 1}ë²ˆì§¸ ì´ë¯¸ì§€:`, value, 'â†’', imageData);
        console.log(`  ì™¼ìª½ ìœ„ì¹˜: x=${leftPos.x}%, y=${leftPos.y}% (SVG ì›ë³¸ í¬ê¸° ì‚¬ìš©)`);
        console.log(`  ì˜¤ë¥¸ìª½ ìœ„ì¹˜: x=${rightPos.x}%, y=${rightPos.y}% (SVG ì›ë³¸ í¬ê¸° ì‚¬ìš©)`);
        
        // ëª¨ë“  ì•…ê¸° ë™ì¼í•œ ë†’ì´ë¡œ ë§ì¶¤ (ë¸Œë¼ìŠ¤ ì•…ê¸° ì¡°ì • ì œê±°)
        const topAdjustment = 0; // ëª¨ë“  ì•…ê¸° ë™ì¼í•œ ë†’ì´
        const adjustedTopY = leftPos.y + topAdjustment;
        
        // ì´ë¯¸ì§€ íƒ€ì…ë³„ ê¸°ë³¸ í¬ê¸° ì„¤ì • (ë°°ì¹˜ í•¨ìˆ˜ì—ì„œ right_circle í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ ìµœì¢… ì¡°ì •ë¨)
        const instrumentNames = ['ë°”ì´ì˜¬ë¦°', 'ë¹„ì˜¬ë¼', 'ì²¼ë¡œ', 'íŠ¸ëŸ¼ë³¸', 'íŠ¸ëŸ¼í«', 'í˜¸ë¥¸', 'í”Œë£»', 'í´ë¼ë¦¬ë„·', 'ì½˜íŠ¸ë¼ë² ì´ìŠ¤'];
        const isInstrument = instrumentNames.includes(value);
        // ê¸°ë³¸ scale ê°’ (ë°°ì¹˜ í•¨ìˆ˜ì—ì„œ right_circle í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ ì¡°ì •ë¨)
        const baseScale = isInstrument ? 0.40 : 0.70; // ì•…ê¸°: 0.40 ìœ ì§€, ì¼ë°˜: 0.65â†’0.70 (ë” í‚¤ì›€)
        
        // ì™¼ìª½ ì´ë¯¸ì§€ë§Œ ìƒì„± (ë“œë˜ê·¸ ê°€ëŠ¥)
        // í¬ê¸°ëŠ” ë°°ì¹˜ í•¨ìˆ˜ì—ì„œ right_circle í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ ì„¤ì •ë¨
        imagesHTML += `<img src="${imageData.left}" 
          class="draggable-img"
          style="position: absolute; left: ${leftPos.x}%; top: ${adjustedTopY}%; width: auto; height: auto; z-index: 10; display: block; margin: 0; padding: 0; border: 0; outline: 0; vertical-align: baseline; line-height: 0; cursor: move; user-select: none; pointer-events: auto;" 
          alt="${value}" 
          draggable="false"
          data-index="${index}"
          data-side="left"
          data-scale="${baseScale}"
          onerror="console.error('âŒ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', '${imageData.left}'); this.alt='ë¡œë“œì‹¤íŒ¨: ${value}'" />`;
      } else if (index >= 7) {
        console.warn(`ì´ë¯¸ì§€ ${index + 1}ë²ˆì€ ìµœëŒ€ ê°œìˆ˜(7ê°œ)ë¥¼ ì´ˆê³¼í•˜ì—¬ ë¬´ì‹œë©ë‹ˆë‹¤.`);
      } else {
        console.warn('ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:', value);
      }
    });
    
    if (imagesHTML) {
      ticketContent.innerHTML = imagesHTML;
      console.log('âœ… ì‚¬ìš©ì ì„ íƒì— ë”°ë¥¸ ì´ë¯¸ì§€ í‘œì‹œ ì™„ë£Œ');
      console.log('í‘œì‹œëœ ì´ë¯¸ì§€ ê°œìˆ˜:', Math.min(selectedValues.length, 7) * 2);
      
      // ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ë“¤ì— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì ìš© ë° ê°„ê²© 0 ë°°ì¹˜
      setTimeout(() => {
        const draggableImages = ticketContent.querySelectorAll('.draggable-img');
        console.log('ğŸ” ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ê°œìˆ˜:', draggableImages.length);
        draggableImages.forEach((img, idx) => {
          console.log(`  ì™¼ìª½ ì´ë¯¸ì§€ ${idx}: index=${img.dataset.index}, side=${img.dataset.side}`);
        });
        
        // ì‚¬ìš©ì ì„ íƒ ì´ë¯¸ì§€ì— ë§ì¶° ìë™ìœ¼ë¡œ í”½ì…€ ê³„ì‚°í•´ì„œ ë”± ë¶™ê²Œ ë°°ì¹˜
        try {
          autoArrangeImagesWithPixelAccuracy(draggableImages, ticketContent);
          
          // ì´ë¯¸ì§€ ë°°ì¹˜ í›„ glow ì› í¬ê¸° ì—…ë°ì´íŠ¸
          setTimeout(() => {
            updateRightCircleGlowSize();
          }, 100);
          
          // ì´ë¯¸ì§€ ë°°ì¹˜ ì™„ë£Œ í›„ ë¡œë”© ì¢…ë£Œ
          setTimeout(() => {
            console.log('ğŸ‰ í‹°ì¼“ ìƒì„± ì™„ë£Œ, ë¡œë”© ì¢…ë£Œ');
            // glow ì› í¬ê¸° ìµœì¢… ì—…ë°ì´íŠ¸
            updateRightCircleGlowSize();
            hideLoading();
          }, 500);
        } catch (error) {
          console.error('âŒ ì´ë¯¸ì§€ ë°°ì¹˜ ì¤‘ ì˜¤ë¥˜:', error);
          hideLoading();
        }
      }, 500);
      
    } else {
      console.log('í‘œì‹œí•  ì´ë¯¸ì§€ê°€ ì—†ìŒ');
      // ì´ë¯¸ì§€ê°€ ì—†ì–´ë„ ë¡œë”© ì¢…ë£Œ
      setTimeout(() => {
        console.log('ğŸ‰ ì´ë¯¸ì§€ ì—†ìŒ, ë¡œë”© ì¢…ë£Œ');
        hideLoading();
      }, 500);
    }
  } else {
    console.log('ì„ íƒëœ í•­ëª©ì´ ì—†ì–´ì„œ ì´ë¯¸ì§€ í‘œì‹œ ì•ˆí•¨');
    // ì„ íƒ í•­ëª©ì´ ì—†ì–´ë„ ë¡œë”© ì¢…ë£Œ
    setTimeout(() => {
      console.log('ğŸ‰ ì„ íƒ í•­ëª© ì—†ìŒ, ë¡œë”© ì¢…ë£Œ');
      hideLoading();
    }, 500);
  }

  // ìµœì¢… ì•ˆì „ì¥ì¹˜: 3ì´ˆ í›„ ë¬´ì¡°ê±´ ë¡œë”© ì¢…ë£Œ
  setTimeout(() => {
    console.log('â° ìµœì¢… ì•ˆì „ì¥ì¹˜: ë¡œë”© ê°•ì œ ì¢…ë£Œ');
    hideLoading();
  }, 3000);

  // optionally, pre-compose ticket to warm cache (no UI)
  try { await composeTicketDataURL(); } catch(e){ /* ignore */ }
  
  } catch (error) {
    console.error('âŒ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
    console.error('ì˜¤ë¥˜ ìŠ¤íƒ:', error.stack);
    // ì˜¤ë¥˜ê°€ ë°œìƒí•´ë„ ë¡œë”© í™”ë©´ì€ ìˆ¨ê¹€
    hideLoading();
  }
})();

// í™”ë©´ í¬ê¸° ë³€ê²½ ì‹œ glow ì› í¬ê¸° ì—…ë°ì´íŠ¸
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    updateRightCircleGlowSize();
  }, 250);
});
</script>
</body>
</html>
